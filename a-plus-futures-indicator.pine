//@version=5
indicator("srchulo futures strict", overlay=true, max_labels_count=500, max_lines_count=500, max_bars_back=5000)

// ---------- Inputs
grpTrend = "Trend / Filters"
emaFastLen = input.int(8, "EMA Fast", group=grpTrend, minval=1)
emaMidLen  = input.int(21, "EMA Mid", group=grpTrend, minval=1)
emaSlowLen = input.int(34, "EMA Slow", group=grpTrend, minval=1)
useRibbon  = input.bool(true, "Require EMA ribbon alignment (LTF)", group=grpTrend)
htfTF      = input.string("15", "HTF EMA ribbon (minutes)", group=grpTrend)

grpVWAP = "VWAP / AVWAP"
useVWAP  = input.bool(true, "Use session VWAP", group=grpVWAP)
useAVWAP = input.bool(true, "Use Anchored VWAP (auto RTH open)", group=grpVWAP)
anchorTime = input.time(timestamp("01 Jan 2025 09:30 -0500"), "Anchored start (unused; auto RTH open)", group=grpVWAP)
pullDist   = input.float(0.10, "Near VWAP distance (% ATR)", group=grpVWAP)
minVWAPBand = input.float(0.20, "Chop guard band (ATR*x)", group=grpVWAP)

grpVol = "Volume"
volLen  = input.int(50, "Vol SMA", group=grpVol)
volMult = input.float(1.5, "Surge ≥ SMA *", group=grpVol)
requireVol = input.bool(true, "Require volume surge", group=grpVol)

grpDoji = "Candle Patterns"
dojiBodyPct = input.float(0.12, "Doji body ≤ x of range", group=grpDoji)
longWickK   = input.float(2.0, "Long wick ≥ body *", group=grpDoji)
nearHiPct   = input.float(0.25, "Body near high", group=grpDoji)
nearLoPct   = input.float(0.25, "Body near low", group=grpDoji)

grpCont = "Continuation / Flag"
flagLookback = input.int(25, "Flag window", group=grpCont)
flagTightPct = input.float(0.45, "Flag tightness (≤ ATR * x)", group=grpCont)
breakBufATR  = input.float(0.10, "Breakout buffer (ATR * x)", group=grpCont)

grpDec = "Decision Engine (weights + gating)"
useCompTrend   = input.bool(true, "Use Trend in score", group=grpDec)
useCompNearVW  = input.bool(true, "Use Near VWAP in score", group=grpDec)
useCompVolume  = input.bool(true, "Use Volume in score", group=grpDec)
useCompPull    = input.bool(true, "Use Pullback/Rally in score", group=grpDec)
useCompReclaim = input.bool(true, "Use VWAP Reclaim in score", group=grpDec)
useCompFlag    = input.bool(true, "Use Flag in score", group=grpDec)
useCompPrec    = input.bool(true, "Use Precision EMA in score", group=grpDec)
useCompCandle  = input.bool(true, "Use Reversal Candle in score", group=grpDec)
useCompEngulf  = input.bool(true, "Use Engulfing in score", group=grpDec)
useCompRetest  = input.bool(true, "Use VWAP Retest/Flip in score", group=grpDec)
useCompBase    = input.bool(true, "Use High/Low Base in score", group=grpDec)
useCompTri     = input.bool(false, "Use Asc/Desc Triangle in score", group=grpDec)
useAtrGate       = input.bool(false, "Use ATR floor gate", group=grpDec)
useSessionFilter = input.bool(true, "Use Session filter", group=grpDec)
useHTFFilter     = input.bool(true, "Use HTF ribbon filter", group=grpDec)
useSlopeFilter   = input.bool(true, "Use EMA slope filter", group=grpDec)
useChopGuard     = input.bool(true, "Use VWAP chop-guard", group=grpDec)
useDailyCapGate  = input.bool(true, "Use Daily-cap gate", group=grpDec)
triggerMode      = input.string("Breakout", "Trigger mode", options=["Score","Simple","Breakout"], group=grpDec)

// NEW: anti-repaint controls
calcOnClose = input.bool(false, "Lock signals on bar close (no flicker)", group=grpDec)
freezeHTF   = input.bool(true, "Freeze HTF values (no intrabar updates)", group=grpDec)

// NEW: toggles for base alignment
requireNearVWBase    = input.bool(false, "Base requires Near-VWAP", group=grpDec)
requireEMAMSideBase  = input.bool(true, "Base requires EMA-Mid side", group=grpDec)
requirePatternBreak  = input.bool(true, "Breakout requires a pattern", group=grpDec)

// Momentum / body quality
bodyAtrMin = input.float(0.12, "Min body as ATR fraction", group=grpDec, minval=0.0, step=0.01)

// EMA side buffer
emaSideBuf = input.float(0.03, "EMA side buffer (ATR x)", group=grpDec, minval=0.0, step=0.01)

// Overextension (Keltner) + CLV guards
kcLen = input.int(20, "Keltner length", group=grpDec, minval=1)
kcMult = input.float(1.5, "Keltner ATR mult", group=grpDec, minval=0.1, step=0.1)
kcBuf = input.float(0.10, "Keltner buffer (ATR x)", group=grpDec, minval=0.0, step=0.01)
clvMinLong = input.float(0.60, "Min close location (long)", group=grpDec, minval=0.0, maxval=1.0, step=0.01)
clvMaxShort = input.float(0.40, "Max close location (short)", group=grpDec, minval=0.0, maxval=1.0, step=0.01)

// 200-SMA guard (shorts only)
useSMAGuard = input.bool(true, "Use 200-SMA guard (shorts)", group=grpDec)
smaLen = input.int(200, "Trend SMA length", group=grpDec, minval=50)
smaBuf = input.float(0.10, "SMA buffer (ATR x)", group=grpDec, minval=0.0, step=0.01)

// NEW: asymmetric breakout + KC slope guard inputs
breakBarsL = input.int(2, "Breakout lookback LONG (bars)", group=grpDec, minval=1)
breakBarsS = input.int(2, "Breakout lookback SHORT (bars)", group=grpDec, minval=1)
useKCSlopeGuard = input.bool(true, "Use Keltner slope guard (shorts)", group=grpDec)

wTrend   = input.int(2, "W Trend", group=grpDec, minval=0, maxval=5)
wVWAPPb  = input.int(1, "W Near VWAP", group=grpDec, minval=0, maxval=5)
wVolume  = input.int(1, "W Volume", group=grpDec, minval=0, maxval=5)
wPull    = input.int(2, "W Pull/Rally", group=grpDec, minval=0, maxval=5)
wReclaim = input.int(3, "W Reclaim", group=grpDec, minval=0, maxval=5)
wFlag    = input.int(0, "W Flag", group=grpDec, minval=0, maxval=5)
wPrec    = input.int(2, "W Precision", group=grpDec, minval=0, maxval=5)
wCandle  = input.int(1, "W Candle", group=grpDec, minval=0, maxval=5)
wEngulf  = input.int(2, "W Engulf", group=grpDec, minval=0, maxval=5)
wRetest  = input.int(3, "W VWAP Retest", group=grpDec, minval=0, maxval=5)
wBase    = input.int(2, "W Base", group=grpDec, minval=0, maxval=5)
wTri     = input.int(1, "W Triangle", group=grpDec, minval=0, maxval=5)

threshLong  = input.int(5, "Score threshold LONG", group=grpDec, minval=1)
threshShort = input.int(5, "Score threshold SHORT", group=grpDec, minval=1)
minAtrTicks = input.int(22, "Min ATR (ticks) gate", group=grpDec)
entryConfirmTicks = input.int(2, "Entry confirmation (ticks beyond signal bar)", group=grpDec, minval=1)
cooldownBars = input.int(10, "Cooldown bars", group=grpDec)
maxSignalsPerDay = input.int(12, "Max signals per day", group=grpDec)
sessionStr = input.session("0935-1600", "RTH windows (exchange time)", group=grpDec)

// Pattern tolerances
ticksTol   = input.int(4, "Structure tolerance (ticks)", group=grpDec)
retestBars = input.int(5, "VWAP retest within N bars", group=grpDec)

// ---------- NEW: Exit/Management
grpExit = "Exit / Management (Continuation Aware)"
usePartialATR    = input.bool(true, "Take partial at 3×ATR from entry", group=grpExit)
partialATRs      = input.float(3.0, "Partial ATR multiple", group=grpExit, step=0.1)
trailATRs        = input.float(1.5, "ATR trail (from HH/LL since entry)", group=grpExit, step=0.1)
exitOnMomHook    = input.bool(true, "Exit-soon on momentum hook (MACD hist turns up/down)", group=grpExit)
exitOnPriorHL    = input.bool(true, "Hard exit on prior bar H/L break", group=grpExit)
exitOnVWAPFlip   = input.bool(true, "Hard exit on VWAP/AVWAP reclaim", group=grpExit)
exitOnEMASpread  = input.bool(true, "Exit-soon on EMA spread narrowing", group=grpExit)
emaSpreadLook    = input.int(3, "EMA spread lookback (bars)", group=grpExit, minval=1)
showTrails       = input.bool(true, "Plot dynamic ATR trails", group=grpExit)
enableExitAlerts = input.bool(true, "Enable exit/partial alerts", group=grpExit)

// --- NEW: Exit-Soon tuning + visual controls
exitHookBars   = input.int(2, "MACD hook pivot bars", group=grpExit, minval=1, maxval=5)
spreadShrinkPct = input.float(0.03, "EMA spread shrink ≥", group=grpExit, step=0.005)
needStruct     = input.bool(true, "Require LH/HL with hook", group=grpExit)
needVolFade    = input.bool(false, "Require volume < SMA on exit-soon", group=grpExit)

showExitSoonFlags = input.bool(true, "Show 'Exit Soon' flags", group=grpExit)
showHardExitFlags = input.bool(true, "Show 'Hard Exit' crosses", group=grpExit)
exitSoonColor  = input.color(color.new(color.yellow, 0), "Exit Soon color", group=grpExit)
hardExitColor  = input.color(color.new(color.orange, 0), "Hard Exit color", group=grpExit)

// ---------- Show / Alerts (MOVED UP so plots can see them)
showContext = input.bool(true, "Plot EMAs + VWAP/AVWAP", group="Show / Alerts")
showSetups  = input.bool(true, "Plot setup arrows", group="Show / Alerts")
enableAlerts = input.bool(true, "Enable confirmed entry alerts", group="Show / Alerts")

// ---------- Core series
atrLen = 14
atr = ta.atr(atrLen)
atrTicks = math.round(atr / syminfo.mintick)
bodySize = math.abs(close - open)
momLongOK = close > open and bodySize >= atr * bodyAtrMin
momShortOK = close < open and bodySize >= atr * bodyAtrMin

emaF = ta.ema(close, emaFastLen)
emaM = ta.ema(close, emaMidLen)
emaS = ta.ema(close, emaSlowLen)

ribbonBull = emaF > emaM and emaM > emaS
ribbonBear = emaF < emaM and emaM < emaS
trendOkLong  = useRibbon ? ribbonBull : true
trendOkShort = useRibbon ? ribbonBear : true

emaSlopeLong  = emaM > emaM[5] and emaS > emaS[5]
emaSlopeShort = emaM < emaM[5] and emaS < emaS[5]

// Session & VWAPs
vwap = ta.vwap(close)
inSess = not na(time(timeframe.period, sessionStr))
sessionStart = inSess and not inSess[1]

// Anchored VWAP auto-anchored to RTH open
var float avwap = na
var float aPV = 0.0
var float aV  = 0.0
if barstate.isnew
    if sessionStart
        aPV := 0.0
        aV  := 0.0
    if inSess
        tp = (high + low + close) / 3.0
        aPV += tp * volume
        aV  += volume
        avwap := aV > 0 ? aPV / aV : na
    if not inSess
        avwap := na

// context plots
plot((showContext and useVWAP) ? vwap : na, "VWAP", color=color.new(color.teal, 0), linewidth=2)
plot((showContext and useAVWAP) ? avwap : na, "Anchor VWAP (RTH Open)", color=color.new(color.purple, 0), linewidth=2)
plot(showContext ? emaF : na, "EMA Fast", color=color.new(color.white, 0))
plot(showContext ? emaM : na, "EMA Mid", color=color.new(color.orange, 0))
plot(showContext ? emaS : na, "EMA Slow", color=color.new(color.maroon, 0))

// HTF EMA ribbon (freeze to last closed HTF bar if freezeHTF)
htfE1 = request.security(syminfo.tickerid, htfTF, ta.ema(close, emaFastLen), lookahead=freezeHTF ? barmerge.lookahead_on : barmerge.lookahead_off)
htfE2 = request.security(syminfo.tickerid, htfTF, ta.ema(close, emaMidLen),  lookahead=freezeHTF ? barmerge.lookahead_on : barmerge.lookahead_off)
htfE3 = request.security(syminfo.tickerid, htfTF, ta.ema(close, emaSlowLen), lookahead=freezeHTF ? barmerge.lookahead_on : barmerge.lookahead_off)
htfBull = htfE1 > htfE2 and htfE2 > htfE3
htfBear = htfE1 < htfE2 and htfE2 < htfE3

// Volume
volSMA = ta.sma(volume, volLen)
volSurge = volume >= volSMA * volMult
volOK = requireVol ? volSurge : true

// Candles
rng = math.max(high - low, syminfo.mintick)
body = math.abs(close - open)
upper = high - math.max(open, close)
lower = math.min(open, close) - low
isDoji = body <= rng * dojiBodyPct
nearHighBody = (high - math.max(open, close)) <= rng * nearHiPct
nearLowBody = (math.min(open, close) - low) <= rng * nearLoPct
dragonfly = isDoji and lower >= body * longWickK and nearHighBody
gravestone = isDoji and upper >= body * longWickK and nearLowBody
hammer = (lower >= body * longWickK) and nearHighBody and not isDoji
shootingStar = (upper >= body * longWickK) and nearLowBody and not isDoji

// Engulf / inside
bullEngulf = close > open and open <= close[1] and close >= open[1] and close > close[1]
bearEngulf = close < open and open >= close[1] and close <= open[1] and close < close[1]
insideBar  = high < high[1] and low > low[1]

// Proximity + chop guard
withinPctOfATR(src, pct) => na(src) ? false : math.abs(close - src) <= atr * pct
nearAnyVWAP_raw = (useVWAP and withinPctOfATR(vwap, pullDist)) or (useAVWAP and withinPctOfATR(avwap, pullDist))
inVWAPChop_raw  = (useVWAP and withinPctOfATR(vwap, minVWAPBand)) or (useAVWAP and withinPctOfATR(avwap, minVWAPBand))
nearAnyVWAP = nearAnyVWAP_raw
inVWAPChop = useChopGuard ? inVWAPChop_raw : false

// Side-of-VWAP + EMA-Mid side + Chop OK
aboveVW = (not useVWAP or close > vwap) and (not useAVWAP or na(avwap) or close > avwap)
belowVW = (not useVWAP or close < vwap) and (not useAVWAP or na(avwap) or close < avwap)
aboveEMAM = close > emaM + atr * emaSideBuf
belowEMAM = close < emaM - atr * emaSideBuf
cgOK = (not useChopGuard) or (not inVWAPChop)

// Overextension (Keltner) + CLV
basisKC = ta.ema((high + low + close) / 3.0, kcLen)
rangeKC = ta.atr(kcLen) * kcMult
kcUp = basisKC + rangeKC
kcDn = basisKC - rangeKC
overLong = close >= kcUp - atr * kcBuf
overShort = close <= kcDn + atr * kcBuf
rngNow = math.max(high - low, syminfo.mintick)
clv = rngNow > 0 ? (close - low) / rngNow : 0.5
clvLongOK = clv >= clvMinLong
clvShortOK = clv <= clvMaxShort

// KC slope guard helpers
kcSlopeUp = kcUp > kcUp[1] and kcDn > kcDn[1]
kcSlopeDown = kcUp < kcUp[1] and kcDn < kcDn[1]

// 200-SMA guard helpers
sma200 = ta.sma(close, smaLen)
aboveSMA = close > sma200 + atr * smaBuf
belowSMA = close < sma200 - atr * smaBuf

// Setups
bullReversalCandle = hammer or dragonfly or (close > open and close > open[1] and low <= low[1])
pullbackLong = trendOkLong and nearAnyVWAP and bullReversalCandle and close > ta.highest(high[1], 1)
bearReversalCandle = shootingStar or gravestone or (close < open and close < open[1] and high >= high[1])
rallyShort = trendOkShort and nearAnyVWAP and bearReversalCandle and close < ta.lowest(low[1], 1)

wasBelowVWAP = useVWAP and close[1] < vwap[1]
nowAboveVWAP = useVWAP and close > vwap
wasAboveVWAP = useVWAP and close[1] > vwap[1]
nowBelowVWAP = useVWAP and close < vwap
vwapReclaimLong = trendOkLong and (wasBelowVWAP and nowAboveVWAP) and volOK
vwapReclaimShort = trendOkShort and (wasAboveVWAP and nowBelowVWAP) and volOK

// VWAP retest/flip (after reclaim)
tolP = atr * 0.10
bullRetest = ta.barssince(wasBelowVWAP and nowAboveVWAP) <= retestBars and math.abs(low - vwap) <= tolP and close > vwap
bearRetest = ta.barssince(wasAboveVWAP and nowBelowVWAP) <= retestBars and math.abs(high - vwap) <= tolP and close < vwap

// Flags / Bases / Triangles
rangeHi = ta.highest(high, flagLookback)
rangeLo = ta.lowest(low, flagLookback)
rangeTight = (rangeHi - rangeLo) <= atr * flagTightPct
bullFlag = trendOkLong and rangeTight and close > rangeHi[1] + atr * breakBufATR
bearFlag = trendOkShort and rangeTight and close < rangeLo[1] - atr * breakBufATR
tolPx = ticksTol * syminfo.mintick
flatHi = math.abs(rangeHi - rangeHi[1]) <= tolPx
flatLo = math.abs(rangeLo - rangeLo[1]) <= tolPx
riseL = ta.lowest(low, flagLookback) > ta.lowest(low, flagLookback)[1]
fallH = ta.highest(high, flagLookback) < ta.highest(high, flagLookback)[1]
highBase = trendOkLong and rangeTight and flatHi and riseL
lowBase = trendOkShort and rangeTight and flatLo and fallH
ascTri = trendOkLong and flatHi and riseL
descTri = trendOkShort and flatLo and fallH

// Precision
precisionLong = trendOkLong and (math.abs(close - emaM) <= atr * 0.15 or math.abs(close - emaS) <= atr * 0.15) and bullReversalCandle
precisionShort = trendOkShort and (math.abs(close - emaM) <= atr * 0.15 or math.abs(close - emaS) <= atr * 0.15) and bearReversalCandle

// Scoring
reclaimLongPrim = wasBelowVWAP and nowAboveVWAP
reclaimShortPrim = wasAboveVWAP and nowBelowVWAP
bullCandle = hammer or dragonfly
bearCandle = shootingStar or gravestone
scoreAdd(c, w, use) => use and c ? w : 0
longScore = scoreAdd(trendOkLong, wTrend, useCompTrend) + scoreAdd(not inVWAPChop and nearAnyVWAP, wVWAPPb, useCompNearVW) + scoreAdd(volOK, wVolume, useCompVolume) + scoreAdd(pullbackLong, wPull, useCompPull) + scoreAdd(reclaimLongPrim, wReclaim, useCompReclaim) + scoreAdd(bullFlag, wFlag, useCompFlag) + scoreAdd(precisionLong, wPrec, useCompPrec) + scoreAdd(bullCandle, wCandle, useCompCandle) + scoreAdd(bullEngulf, wEngulf, useCompEngulf) + scoreAdd(bullRetest, wRetest, useCompRetest) + scoreAdd(highBase, wBase, useCompBase) + scoreAdd(ascTri, wTri, useCompTri)
shortScore = scoreAdd(trendOkShort, wTrend, useCompTrend) + scoreAdd(not inVWAPChop and nearAnyVWAP, wVWAPPb, useCompNearVW) + scoreAdd(volOK, wVolume, useCompVolume) + scoreAdd(rallyShort, wPull, useCompPull) + scoreAdd(reclaimShortPrim, wReclaim, useCompReclaim) + scoreAdd(bearFlag, wFlag, useCompFlag) + scoreAdd(precisionShort, wPrec, useCompPrec) + scoreAdd(bearCandle, wCandle, useCompCandle) + scoreAdd(bearEngulf, wEngulf, useCompEngulf) + scoreAdd(bearRetest, wRetest, useCompRetest) + scoreAdd(lowBase, wBase, useCompBase) + scoreAdd(descTri, wTri, useCompTri)

// Gating toggles
gateSessOK = useSessionFilter ? inSess : true
gateAtrOK = useAtrGate ? atrTicks >= minAtrTicks : true
gateHTFLong = useHTFFilter ? htfBull : true
gateHTFShort = useHTFFilter ? htfBear : true
gateSlopeL = useSlopeFilter ? emaSlopeLong : true
gateSlopeS = useSlopeFilter ? emaSlopeShort : true

// Cooldown + daily cap
var int lastSignalBar = na
newDay = ta.change(time("D")) != 0
var int signalsToday = 0
if newDay
    signalsToday := 0
readyForNew = na(lastSignalBar) or (bar_index - lastSignalBar > cooldownBars)
capRaw = signalsToday < maxSignalsPerDay
gateDailyOK = useDailyCapGate ? capRaw : true

// SIMPLE triggers (bypass score if chosen)
simpleLong = trendOkLong and (precisionLong or vwapReclaimLong or bullRetest or bullEngulf or pullbackLong or bullFlag or highBase or ascTri) and (not useChopGuard or not inVWAPChop)
simpleShort = trendOkShort and (precisionShort or vwapReclaimShort or bearRetest or bearEngulf or rallyShort or bearFlag or lowBase or descTri) and (not useChopGuard or not inVWAPChop)

// NEW: "pattern required" set for Breakout
anyPatternLong = precisionLong or vwapReclaimLong or bullRetest or bullEngulf or pullbackLong or bullFlag or highBase or ascTri
anyPatternShort = precisionShort or vwapReclaimShort or bearRetest or bearEngulf or rallyShort or bearFlag or lowBase or descTri

// NEW: base gate bundles
baseLongGates = readyForNew and gateDailyOK and gateSessOK and gateAtrOK and gateHTFLong and gateSlopeL and trendOkLong and cgOK and aboveVW and (not requireEMAMSideBase or aboveEMAM) and (not requireNearVWBase or nearAnyVWAP) and momLongOK and (not overLong) and clvLongOK
baseShortGates = readyForNew and gateDailyOK and gateSessOK and gateAtrOK and gateHTFShort and gateSlopeS and trendOkShort and cgOK and belowVW and (not requireEMAMSideBase or belowEMAM) and (not requireNearVWBase or nearAnyVWAP) and momShortOK and (not overShort) and clvShortOK and (not useSMAGuard or belowSMA) and (not useKCSlopeGuard or kcSlopeDown)

// Final setups (mode driven)
useScore = triggerMode == "Score"
useSimple = triggerMode == "Simple"
useBreak = triggerMode == "Breakout"
baseLongSetup_raw = ((useScore ? (longScore >= threshLong) : (useSimple ? simpleLong : (not requirePatternBreak or anyPatternLong))) and baseLongGates)
baseShortSetup_raw = ((useScore ? (shortScore >= threshShort) : (useSimple ? simpleShort : (not requirePatternBreak or anyPatternShort))) and baseShortGates)

// Confirmation + asymmetric breakout
rngOK2 = (high - low) >= atr * 0.20
longStopPrice = high + entryConfirmTicks * syminfo.mintick
shortStopPrice = low - entryConfirmTicks * syminfo.mintick
breakoutLongNow  = rngOK2 and high >= ta.highest(high, breakBarsL)[1] + entryConfirmTicks * syminfo.mintick
breakoutShortNow = rngOK2 and low  <= ta.lowest(low, breakBarsS)[1]  - entryConfirmTicks * syminfo.mintick
longConfirm_raw  = useBreak ? (baseLongSetup_raw and breakoutLongNow) : (baseLongSetup_raw[1] and high >= longStopPrice[1])
shortConfirm_raw = useBreak ? (baseShortSetup_raw and breakoutShortNow) : (baseShortSetup_raw[1] and low <= shortStopPrice[1])

// --- Finalization: lock on bar close if enabled
finalize(b) => calcOnClose ? (barstate.isconfirmed ? b : false) : b
baseLongSetup  = finalize(baseLongSetup_raw)
baseShortSetup = finalize(baseShortSetup_raw)
longConfirm    = finalize(longConfirm_raw)
shortConfirm   = finalize(shortConfirm_raw)

// ---------- NEW: Position state, momentum & exits
[macdLine, macdSignal, macdHist] = ta.macd(close, 12, 26, 9)
spreadNow = math.abs(emaM - emaF)
spreadPrev = math.abs(emaM[emaSpreadLook] - emaF[emaSpreadLook])

var bool inLong = false
var bool inShort = false
var float entryPrice = na
var int entrySide = 0
longEnter = barstate.isconfirmed and longConfirm
shortEnter = barstate.isconfirmed and shortConfirm
if longEnter
    inLong := true
    inShort := false
    entryPrice := close
    entrySide := 1
if shortEnter
    inShort := true
    inLong := false
    entryPrice := close
    entrySide := -1

barsSinceLong = ta.barssince(longEnter)
barsSinceShort = ta.barssince(shortEnter)

// SAFE dynamic lengths (no buffer overflow)
histAvail = bar_index + 1
_safeLen(x) => math.max(1, math.min(histAvail, math.min(500, nz(x) + 1)))
lenL = _safeLen(barsSinceLong)
lenS = _safeLen(barsSinceShort)

llSince = ta.lowest(low, lenL)
hhSince = ta.highest(high, lenS)
trailLong = llSince - atr * trailATRs
trailShort = hhSince + atr * trailATRs

partialLong = inLong and usePartialATR and close >= entryPrice + atr * partialATRs
partialShort = inShort and usePartialATR and close <= entryPrice - atr * partialATRs

// --- Exit-Soon conditions (less chatty)
macdHookDn = ta.change(macdHist) < 0 and ta.change(macdHist, exitHookBars) >= 0
macdHookUp = ta.change(macdHist) > 0 and ta.change(macdHist, exitHookBars) <= 0
spreadNarrow = spreadNow <= spreadPrev * (1 - spreadShrinkPct)
lowerHigh = high <= high[1]
higherLow = low  >= low[1]
volFade = volume < volSMA

momHookLong  = inLong  and exitOnMomHook and macdHookDn
momHookShort = inShort and exitOnMomHook and macdHookUp
emaNarrowLong  = inLong  and exitOnEMASpread and spreadNarrow
emaNarrowShort = inShort and exitOnEMASpread and spreadNarrow

hardExitLong = inLong and ((close <= trailLong) or (exitOnVWAPFlip and ((useVWAP and close < vwap) or (useAVWAP and (not na(avwap) and close < avwap)))) or (exitOnPriorHL and close < low[1]))
hardExitShort = inShort and ((close >= trailShort) or (exitOnVWAPFlip and ((useVWAP and close > vwap) or (useAVWAP and (not na(avwap) and close > avwap)))) or (exitOnPriorHL and close > high[1]))

exitSoonLong  = inLong  and ((momHookLong or emaNarrowLong))  and (not needStruct or lowerHigh)  and (not needVolFade or volFade)
exitSoonShort = inShort and ((momHookShort or emaNarrowShort)) and (not needStruct or higherLow) and (not needVolFade or volFade)

// auto-flat state on hard exit
if barstate.isconfirmed and hardExitLong
    inLong := false
    entrySide := 0
if barstate.isconfirmed and hardExitShort
    inShort := false
    entrySide := 0

// ---------- Trails & Exit markers
plot(showTrails and inLong ? trailLong : na, "Long ATR Trail", color=color.new(color.lime, 0), linewidth=1, style=plot.style_linebr)
plot(showTrails and inShort ? trailShort : na, "Short ATR Trail", color=color.new(color.red, 0), linewidth=1, style=plot.style_linebr)
plotshape(partialLong, title="Partial LONG 3xATR", style=shape.circle, location=location.abovebar, color=color.new(color.lime, 0), size=size.tiny, text="PARTIAL")
plotshape(partialShort, title="Partial SHORT 3xATR", style=shape.circle, location=location.belowbar, color=color.new(color.red, 0), size=size.tiny, text="PARTIAL")
plotshape(showExitSoonFlags and exitSoonLong,  title="Exit Soon LONG",  style=shape.flag,  location=location.abovebar, color=exitSoonColor, size=size.tiny, text="EXIT SOON")
plotshape(showExitSoonFlags and exitSoonShort, title="Exit Soon SHORT", style=shape.flag,  location=location.belowbar, color=exitSoonColor, size=size.tiny, text="EXIT SOON")
plotshape(showHardExitFlags and hardExitLong,  title="HARD EXIT LONG",  style=shape.cross, location=location.abovebar, color=hardExitColor, size=size.tiny, text="EXIT")
plotshape(showHardExitFlags and hardExitShort, title="HARD EXIT SHORT", style=shape.cross, location=location.belowbar, color=hardExitColor, size=size.tiny, text="EXIT")

// Plot arrows (finalized only)
plotshape(showSetups and baseLongSetup, title="Setup LONG", style=shape.triangleup, location=location.belowbar, color=color.new(color.lime, 40), size=size.tiny, text="setup")
plotshape(showSetups and baseShortSetup, title="Setup SHORT", style=shape.triangledown, location=location.abovebar, color=color.new(color.red, 40), size=size.tiny, text="setup")
plotshape(longConfirm, title="A+ LONG (confirmed)", style=shape.triangleup, location=location.belowbar, color=color.lime, size=size.large, text="A+ LONG")
plotshape(shortConfirm, title="A+ SHORT (confirmed)", style=shape.triangledown, location=location.abovebar, color=color.red, size=size.large, text="A+ SHORT")
bgcolor(longConfirm ? color.new(color.lime, 85) : shortConfirm ? color.new(color.red, 85) : na)

// A+ light
var label light = na
if barstate.islast
    if not na(light)
        label.delete(light)
    lightText = longConfirm ? "A+ LONG" : shortConfirm ? "A+ SHORT" : "NO A+"
    lightBg = longConfirm ? color.new(color.lime, 0) : shortConfirm ? color.new(color.red, 0) : color.new(color.gray, 80)
    light := label.new(bar_index, high, lightText, xloc=xloc.bar_index, yloc=yloc.abovebar, style=label.style_label_down, textcolor=color.black, color=lightBg, size=size.small)

// Alerts (entries)
alertcondition(enableAlerts and longConfirm, title="A+ LONG ENTRY", message="A+ LONG entry fired")
alertcondition(enableAlerts and shortConfirm, title="A+ SHORT ENTRY", message="A+ SHORT entry fired")

// Alerts (partials / exits)
alertcondition(enableExitAlerts and partialLong, title="A+ LONG PARTIAL", message="A+ LONG: take partial at 3x ATR from entry")
alertcondition(enableExitAlerts and partialShort, title="A+ SHORT PARTIAL", message="A+ SHORT: take partial at 3x ATR from entry")
alertcondition(enableExitAlerts and exitSoonLong,  title="A+ LONG EXIT SOON",  message="A+ LONG: momentum slowing / EMA spread narrowing")
alertcondition(enableExitAlerts and exitSoonShort, title="A+ SHORT EXIT SOON", message="A+ SHORT: momentum slowing / EMA spread narrowing")
alertcondition(enableExitAlerts and hardExitLong,  title="A+ LONG HARD EXIT",  message="A+ LONG: trail/VWAP/structure break — exit")
alertcondition(enableExitAlerts and hardExitShort, title="A+ SHORT HARD EXIT", message="A+ SHORT: trail/VWAP/structure break — exit")
