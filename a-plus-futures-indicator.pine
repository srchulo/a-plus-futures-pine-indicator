//@version=5
indicator("srchulo futures strict", overlay=true, max_labels_count=500, max_lines_count=500)

// ---------- Inputs
grpTrend = "Trend / Filters"
emaFastLen = input.int(8, "EMA Fast", group=grpTrend, minval=1)
emaMidLen  = input.int(21, "EMA Mid", group=grpTrend, minval=1)
emaSlowLen = input.int(34, "EMA Slow", group=grpTrend, minval=1)
useRibbon  = input.bool(true, "Require EMA ribbon alignment (LTF)", group=grpTrend)
htfTF      = input.string("15", "HTF EMA ribbon (minutes)", group=grpTrend)

grpVWAP = "VWAP / AVWAP"
useVWAP  = input.bool(true, "Use session VWAP", group=grpVWAP)
useAVWAP = input.bool(true, "Use Anchored VWAP (auto RTH open)", group=grpVWAP)
anchorTime = input.time(timestamp("01 Jan 2025 09:30 -0500"), "Anchored start (unused; auto RTH open)", group=grpVWAP)
pullDist   = input.float(0.10, "Near VWAP distance (% ATR)", group=grpVWAP)
minVWAPBand = input.float(0.20, "Chop guard band (ATR*x)", group=grpVWAP)

grpVol = "Volume"
volLen  = input.int(50, "Vol SMA", group=grpVol)
volMult = input.float(1.5, "Surge ≥ SMA *", group=grpVol)
requireVol = input.bool(true, "Require volume surge", group=grpVol)

grpDoji = "Candle Patterns"
dojiBodyPct = input.float(0.12, "Doji body ≤ x of range", group=grpDoji)
longWickK   = input.float(2.0, "Long wick ≥ body *", group=grpDoji)
nearHiPct   = input.float(0.25, "Body near high", group=grpDoji)
nearLoPct   = input.float(0.25, "Body near low", group=grpDoji)

grpCont = "Continuation / Flag"
flagLookback = input.int(25, "Flag window", group=grpCont)
flagTightPct = input.float(0.45, "Flag tightness (≤ ATR * x)", group=grpCont)
breakBufATR  = input.float(0.10, "Breakout buffer (ATR * x)", group=grpCont)

grpDec = "Decision Engine (weights + gating)"
useCompTrend   = input.bool(true, "Use Trend in score", group=grpDec)
useCompNearVW  = input.bool(true, "Use Near VWAP in score", group=grpDec)
useCompVolume  = input.bool(true, "Use Volume in score", group=grpDec)
useCompPull    = input.bool(true, "Use Pullback/Rally in score", group=grpDec)
useCompReclaim = input.bool(true, "Use VWAP Reclaim in score", group=grpDec)
useCompFlag    = input.bool(true, "Use Flag in score", group=grpDec)
useCompPrec    = input.bool(true, "Use Precision EMA in score", group=grpDec)
useCompCandle  = input.bool(true, "Use Reversal Candle in score", group=grpDec)
useCompEngulf  = input.bool(true, "Use Engulfing in score", group=grpDec)
useCompRetest  = input.bool(true, "Use VWAP Retest/Flip in score", group=grpDec)
useCompBase    = input.bool(true, "Use High/Low Base in score", group=grpDec)
useCompTri     = input.bool(false, "Use Asc/Desc Triangle in score", group=grpDec)

useAtrGate       = input.bool(false, "Use ATR floor gate", group=grpDec)
useSessionFilter = input.bool(true, "Use Session filter", group=grpDec)
useHTFFilter     = input.bool(true, "Use HTF ribbon filter", group=grpDec)
useSlopeFilter   = input.bool(true, "Use EMA slope filter", group=grpDec)
useChopGuard     = input.bool(true, "Use VWAP chop-guard", group=grpDec)
useDailyCapGate  = input.bool(true, "Use Daily-cap gate", group=grpDec)
triggerMode      = input.string("Breakout", "Trigger mode", options=["Score","Simple","Breakout"], group=grpDec)

// NEW: toggles for base alignment
requireNearVWBase    = input.bool(false, "Base requires Near-VWAP", group=grpDec)
requireEMAMSideBase  = input.bool(true, "Base requires EMA-Mid side", group=grpDec)
requirePatternBreak  = input.bool(true, "Breakout requires a pattern", group=grpDec)

// Momentum / body quality
bodyAtrMin = input.float(0.12, "Min body as ATR fraction", group=grpDec, minval=0.0, step=0.01)

// EMA side buffer
emaSideBuf = input.float(0.03, "EMA side buffer (ATR x)", group=grpDec, minval=0.0, step=0.01)

// Overextension (Keltner) + CLV guards
kcLen = input.int(20, "Keltner length", group=grpDec, minval=1)
kcMult = input.float(1.5, "Keltner ATR mult", group=grpDec, minval=0.1, step=0.1)
kcBuf = input.float(0.10, "Keltner buffer (ATR x)", group=grpDec, minval=0.0, step=0.01)
clvMinLong = input.float(0.60, "Min close location (long)", group=grpDec, minval=0.0, maxval=1.0, step=0.01)
clvMaxShort = input.float(0.40, "Max close location (short)", group=grpDec, minval=0.0, maxval=1.0, step=0.01)

// 200-SMA guard (shorts only)
useSMAGuard = input.bool(true, "Use 200-SMA guard (shorts)", group=grpDec)
smaLen = input.int(200, "Trend SMA length", group=grpDec, minval=50)
smaBuf = input.float(0.10, "SMA buffer (ATR x)", group=grpDec, minval=0.0, step=0.01)

// NEW: asymmetric breakout + KC slope guard inputs
breakBarsL = input.int(2, "Breakout lookback LONG (bars)", group=grpDec, minval=1)
breakBarsS = input.int(2, "Breakout lookback SHORT (bars)", group=grpDec, minval=1)
useKCSlopeGuard = input.bool(true, "Use Keltner slope guard (shorts)", group=grpDec)

wTrend   = input.int(2, "W Trend", group=grpDec, minval=0, maxval=5)
wVWAPPb  = input.int(1, "W Near VWAP", group=grpDec, minval=0, maxval=5)
wVolume  = input.int(1, "W Volume", group=grpDec, minval=0, maxval=5)
wPull    = input.int(2, "W Pull/Rally", group=grpDec, minval=0, maxval=5)
wReclaim = input.int(3, "W Reclaim", group=grpDec, minval=0, maxval=5)
wFlag    = input.int(0, "W Flag", group=grpDec, minval=0, maxval=5)
wPrec    = input.int(2, "W Precision", group=grpDec, minval=0, maxval=5)
wCandle  = input.int(1, "W Candle", group=grpDec, minval=0, maxval=5)
wEngulf  = input.int(2, "W Engulf", group=grpDec, minval=0, maxval=5)
wRetest  = input.int(3, "W VWAP Retest", group=grpDec, minval=0, maxval=5)
wBase    = input.int(2, "W Base", group=grpDec, minval=0, maxval=5)
wTri     = input.int(1, "W Triangle", group=grpDec, minval=0, maxval=5)

threshLong  = input.int(5, "Score threshold LONG", group=grpDec, minval=1)
threshShort = input.int(5, "Score threshold SHORT", group=grpDec, minval=1)
minAtrTicks = input.int(22, "Min ATR (ticks) gate", group=grpDec)
entryConfirmTicks = input.int(2, "Entry confirmation (ticks beyond signal bar)", group=grpDec, minval=1)
cooldownBars = input.int(10, "Cooldown bars", group=grpDec)
maxSignalsPerDay = input.int(12, "Max signals per day", group=grpDec)
sessionStr = input.session("0935-1600", "RTH windows (exchange time)", group=grpDec)

// Pattern tolerances
ticksTol   = input.int(4, "Structure tolerance (ticks)", group=grpDec)
retestBars = input.int(5, "VWAP retest within N bars", group=grpDec)

// ---------- Show / Alerts
grpShow = "Show / Alerts"
showContext = input.bool(true, "Plot EMAs + VWAP/AVWAP", group=grpShow)
showSetups  = input.bool(true, "Plot setup arrows", group=grpShow)
enableAlerts = input.bool(true, "Enable confirmed entry alerts", group=grpShow)

// ---------- Core series
atrLen = 14
atr = ta.atr(atrLen)
atrTicks = math.round(atr / syminfo.mintick)
bodySize = math.abs(close - open)
momLongOK = close > open and bodySize >= atr * bodyAtrMin
momShortOK = close < open and bodySize >= atr * bodyAtrMin

emaF = ta.ema(close, emaFastLen)
emaM = ta.ema(close, emaMidLen)
emaS = ta.ema(close, emaSlowLen)

ribbonBull = emaF > emaM and emaM > emaS
ribbonBear = emaF < emaM and emaM < emaS
trendOkLong  = useRibbon ? ribbonBull : true
trendOkShort = useRibbon ? ribbonBear : true

emaSlopeLong  = emaM > emaM[5] and emaS > emaS[5]
emaSlopeShort = emaM < emaM[5] and emaS < emaS[5]

// Session & VWAPs
vwap = ta.vwap(close)
inSess = not na(time(timeframe.period, sessionStr))
sessionStart = inSess and not inSess[1]

// Anchored VWAP auto-anchored to RTH open
var float avwap = na
var float aPV = 0.0
var float aV  = 0.0
if barstate.isnew
    if sessionStart
        aPV := 0.0
        aV  := 0.0
    if inSess
        tp = (high + low + close) / 3.0
        aPV += tp * volume
        aV  += volume
        avwap := aV > 0 ? aPV / aV : na
    if not inSess
        avwap := na

// context plots
plot((showContext and useVWAP) ? vwap : na, "VWAP", color=color.new(color.teal, 0), linewidth=2)
plot((showContext and useAVWAP) ? avwap : na, "Anchor VWAP (RTH Open)", color=color.new(color.purple, 0), linewidth=2)
plot(showContext ? emaF : na, "EMA Fast", color=color.new(color.white, 0))
plot(showContext ? emaM : na, "EMA Mid", color=color.new(color.orange, 0))
plot(showContext ? emaS : na, "EMA Slow", color=color.new(color.maroon, 0))

// HTF EMA ribbon
htfE1 = request.security(syminfo.tickerid, htfTF, ta.ema(close, emaFastLen))
htfE2 = request.security(syminfo.tickerid, htfTF, ta.ema(close, emaMidLen))
htfE3 = request.security(syminfo.tickerid, htfTF, ta.ema(close, emaSlowLen))
htfBull = htfE1 > htfE2 and htfE2 > htfE3
htfBear = htfE1 < htfE2 and htfE2 < htfE3

// Volume
volSMA = ta.sma(volume, volLen)
volSurge = volume >= volSMA * volMult
volOK = requireVol ? volSurge : true

// Candles
rng = math.max(high - low, syminfo.mintick)
body = math.abs(close - open)
upper = high - math.max(open, close)
lower = math.min(open, close) - low
isDoji = body <= rng * dojiBodyPct
nearHighBody = (high - math.max(open, close)) <= rng * nearHiPct
nearLowBody = (math.min(open, close) - low) <= rng * nearLoPct
dragonfly = isDoji and lower >= body * longWickK and nearHighBody
gravestone = isDoji and upper >= body * longWickK and nearLowBody
hammer = (lower >= body * longWickK) and nearHighBody and not isDoji
shootingStar = (upper >= body * longWickK) and nearLowBody and not isDoji

// Engulf / inside
bullEngulf = close > open and open <= close[1] and close >= open[1] and close > close[1]
bearEngulf = close < open and open >= close[1] and close <= open[1] and close < close[1]
insideBar  = high < high[1] and low > low[1]

// Proximity + chop guard
withinPctOfATR(src, pct) => na(src) ? false : math.abs(close - src) <= atr * pct
nearAnyVWAP_raw = (useVWAP and withinPctOfATR(vwap, pullDist)) or (useAVWAP and withinPctOfATR(avwap, pullDist))
inVWAPChop_raw  = (useVWAP and withinPctOfATR(vwap, minVWAPBand)) or (useAVWAP and withinPctOfATR(avwap, minVWAPBand))
nearAnyVWAP = nearAnyVWAP_raw
inVWAPChop = useChopGuard ? inVWAPChop_raw : false

// Side-of-VWAP + EMA-Mid side + Chop OK
aboveVW = (not useVWAP or close > vwap) and (not useAVWAP or na(avwap) or close > avwap)
belowVW = (not useVWAP or close < vwap) and (not useAVWAP or na(avwap) or close < avwap)
aboveEMAM = close > emaM + atr * emaSideBuf
belowEMAM = close < emaM - atr * emaSideBuf
cgOK = (not useChopGuard) or (not inVWAPChop)

// Overextension (Keltner) + CLV
basisKC = ta.ema((high + low + close) / 3.0, kcLen)
rangeKC = ta.atr(kcLen) * kcMult
kcUp = basisKC + rangeKC
kcDn = basisKC - rangeKC
overLong = close >= kcUp - atr * kcBuf
overShort = close <= kcDn + atr * kcBuf
rngNow = math.max(high - low, syminfo.mintick)
clv = rngNow > 0 ? (close - low) / rngNow : 0.5
clvLongOK = clv >= clvMinLong
clvShortOK = clv <= clvMaxShort

// KC slope guard helpers
kcSlopeUp = kcUp > kcUp[1] and kcDn > kcDn[1]
kcSlopeDown = kcUp < kcUp[1] and kcDn < kcDn[1]

// 200-SMA guard helpers
sma200 = ta.sma(close, smaLen)
aboveSMA = close > sma200 + atr * smaBuf
belowSMA = close < sma200 - atr * smaBuf

// Setups
bullReversalCandle = hammer or dragonfly or (close > open and close > open[1] and low <= low[1])
pullbackLong = trendOkLong and nearAnyVWAP and bullReversalCandle and close > ta.highest(high[1], 1)
bearReversalCandle = shootingStar or gravestone or (close < open and close < open[1] and high >= high[1])
rallyShort = trendOkShort and nearAnyVWAP and bearReversalCandle and close < ta.lowest(low[1], 1)

wasBelowVWAP = useVWAP and close[1] < vwap[1]
nowAboveVWAP = useVWAP and close > vwap
wasAboveVWAP = useVWAP and close[1] > vwap[1]
nowBelowVWAP = useVWAP and close < vwap
vwapReclaimLong = trendOkLong and (wasBelowVWAP and nowAboveVWAP) and volOK
vwapReclaimShort = trendOkShort and (wasAboveVWAP and nowBelowVWAP) and volOK

// VWAP retest/flip (after reclaim)
tolP = atr * 0.10
bullRetest = ta.barssince(wasBelowVWAP and nowAboveVWAP) <= retestBars and math.abs(low - vwap) <= tolP and close > vwap
bearRetest = ta.barssince(wasAboveVWAP and nowBelowVWAP) <= retestBars and math.abs(high - vwap) <= tolP and close < vwap

// Flags / Bases / Triangles
rangeHi = ta.highest(high, flagLookback)
rangeLo = ta.lowest(low, flagLookback)
rangeTight = (rangeHi - rangeLo) <= atr * flagTightPct
bullFlag = trendOkLong and rangeTight and close > rangeHi[1] + atr * breakBufATR
bearFlag = trendOkShort and rangeTight and close < rangeLo[1] - atr * breakBufATR
tolPx = ticksTol * syminfo.mintick
flatHi = math.abs(rangeHi - rangeHi[1]) <= tolPx
flatLo = math.abs(rangeLo - rangeLo[1]) <= tolPx
riseL = ta.lowest(low, flagLookback) > ta.lowest(low, flagLookback)[1]
fallH = ta.highest(high, flagLookback) < ta.highest(high, flagLookback)[1]
highBase = trendOkLong and rangeTight and flatHi and riseL
lowBase = trendOkShort and rangeTight and flatLo and fallH
ascTri = trendOkLong and flatHi and riseL
descTri = trendOkShort and flatLo and fallH

// Precision
precisionLong = trendOkLong and (math.abs(close - emaM) <= atr * 0.15 or math.abs(close - emaS) <= atr * 0.15) and bullReversalCandle
precisionShort = trendOkShort and (math.abs(close - emaM) <= atr * 0.15 or math.abs(close - emaS) <= atr * 0.15) and bearReversalCandle

// Scoring
reclaimLongPrim = wasBelowVWAP and nowAboveVWAP
reclaimShortPrim = wasAboveVWAP and nowBelowVWAP
bullCandle = hammer or dragonfly
bearCandle = shootingStar or gravestone
scoreAdd(c, w, use) => use and c ? w : 0
longScore = scoreAdd(trendOkLong, wTrend, useCompTrend) + scoreAdd(not inVWAPChop and nearAnyVWAP, wVWAPPb, useCompNearVW) + scoreAdd(volOK, wVolume, useCompVolume) + scoreAdd(pullbackLong, wPull, useCompPull) + scoreAdd(reclaimLongPrim, wReclaim, useCompReclaim) + scoreAdd(bullFlag, wFlag, useCompFlag) + scoreAdd(precisionLong, wPrec, useCompPrec) + scoreAdd(bullCandle, wCandle, useCompCandle) + scoreAdd(bullEngulf, wEngulf, useCompEngulf) + scoreAdd(bullRetest, wRetest, useCompRetest) + scoreAdd(highBase, wBase, useCompBase) + scoreAdd(ascTri, wTri, useCompTri)
shortScore = scoreAdd(trendOkShort, wTrend, useCompTrend) + scoreAdd(not inVWAPChop and nearAnyVWAP, wVWAPPb, useCompNearVW) + scoreAdd(volOK, wVolume, useCompVolume) + scoreAdd(rallyShort, wPull, useCompPull) + scoreAdd(reclaimShortPrim, wReclaim, useCompReclaim) + scoreAdd(bearFlag, wFlag, useCompFlag) + scoreAdd(precisionShort, wPrec, useCompPrec) + scoreAdd(bearCandle, wCandle, useCompCandle) + scoreAdd(bearEngulf, wEngulf, useCompEngulf) + scoreAdd(bearRetest, wRetest, useCompRetest) + scoreAdd(lowBase, wBase, useCompBase) + scoreAdd(descTri, wTri, useCompTri)

// Gating toggles
gateSessOK = useSessionFilter ? inSess : true
gateAtrOK = useAtrGate ? atrTicks >= minAtrTicks : true
gateHTFLong = useHTFFilter ? htfBull : true
gateHTFShort = useHTFFilter ? htfBear : true
gateSlopeL = useSlopeFilter ? emaSlopeLong : true
gateSlopeS = useSlopeFilter ? emaSlopeShort : true

// Cooldown + daily cap
var int lastSignalBar = na
newDay = ta.change(time("D")) != 0
var int signalsToday = 0
if newDay
    signalsToday := 0
readyForNew = na(lastSignalBar) or (bar_index - lastSignalBar > cooldownBars)
capRaw = signalsToday < maxSignalsPerDay
gateDailyOK = useDailyCapGate ? capRaw : true

// SIMPLE triggers (bypass score if chosen)
simpleLong = trendOkLong and (precisionLong or vwapReclaimLong or bullRetest or bullEngulf or pullbackLong or bullFlag or highBase or ascTri) and (not useChopGuard or not inVWAPChop)
simpleShort = trendOkShort and (precisionShort or vwapReclaimShort or bearRetest or bearEngulf or rallyShort or bearFlag or lowBase or descTri) and (not useChopGuard or not inVWAPChop)

// NEW: "pattern required" set for Breakout
anyPatternLong = precisionLong or vwapReclaimLong or bullRetest or bullEngulf or pullbackLong or bullFlag or highBase or ascTri
anyPatternShort = precisionShort or vwapReclaimShort or bearRetest or bearEngulf or rallyShort or bearFlag or lowBase or descTri

// NEW: base gate bundles (single-line) — include Keltner, CLV, 200-SMA guard (shorts) and KC slope guard (shorts)
baseLongGates = readyForNew and gateDailyOK and gateSessOK and gateAtrOK and gateHTFLong and gateSlopeL and trendOkLong and cgOK and aboveVW and (not requireEMAMSideBase or aboveEMAM) and (not requireNearVWBase or nearAnyVWAP) and momLongOK and (not overLong) and clvLongOK
baseShortGates = readyForNew and gateDailyOK and gateSessOK and gateAtrOK and gateHTFShort and gateSlopeS and trendOkShort and cgOK and belowVW and (not requireEMAMSideBase or belowEMAM) and (not requireNearVWBase or nearAnyVWAP) and momShortOK and (not overShort) and clvShortOK and (not useSMAGuard or belowSMA) and (not useKCSlopeGuard or kcSlopeDown)

// Final setups (mode driven) — all single-line with ternaries
useScore = triggerMode == "Score"
useSimple = triggerMode == "Simple"
useBreak = triggerMode == "Breakout"
baseLongSetup = ((useScore ? (longScore >= threshLong) : (useSimple ? simpleLong : (not requirePatternBreak or anyPatternLong))) and baseLongGates)
baseShortSetup = ((useScore ? (shortScore >= threshShort) : (useSimple ? simpleShort : (not requirePatternBreak or anyPatternShort))) and baseShortGates)

// Confirmation (less twitchy) + asymmetric breakout
rngOK2 = (high - low) >= atr * 0.20
longStopPrice = high + entryConfirmTicks * syminfo.mintick
shortStopPrice = low - entryConfirmTicks * syminfo.mintick
breakoutLongNow  = rngOK2 and high >= ta.highest(high, breakBarsL)[1] + entryConfirmTicks * syminfo.mintick
breakoutShortNow = rngOK2 and low  <= ta.lowest(low, breakBarsS)[1]  - entryConfirmTicks * syminfo.mintick
longConfirm = useBreak ? (baseLongSetup and breakoutLongNow) : (baseLongSetup[1] and high >= longStopPrice[1])
shortConfirm = useBreak ? (baseShortSetup and breakoutShortNow) : (baseShortSetup[1] and low <= shortStopPrice[1])

// Debug panel
grpDbg = "Debug"
showGateDebug = input.bool(false, "Show Gate Debug panel", group=grpDbg)
gateColor(b) => b ? color.new(color.lime, 0) : color.new(color.red, 0)
textYesNo(b) => b ? "YES" : "NO"
var table dbg = na
if barstate.isfirst
    dbg := table.new(position.top_right, 4, 24, border_width=1)
if showGateDebug and barstate.islast
    modeTxt = useScore ? "Score" : useSimple ? "Simple" : "Breakout"
    table.cell(dbg, 0, 0, "Gate", text_color=color.black, bgcolor=color.new(color.yellow, 0))
    table.cell(dbg, 1, 0, "LONG", text_color=color.black, bgcolor=color.new(color.yellow, 0))
    table.cell(dbg, 2, 0, "SHORT", text_color=color.black, bgcolor=color.new(color.yellow, 0))
    table.cell(dbg, 3, 0, "Mode: " + modeTxt, text_color=color.black, bgcolor=color.new(color.orange, 20))
    table.cell(dbg, 0, 1, "Setup Active")
    table.cell(dbg, 1, 1, textYesNo(baseLongSetup), bgcolor=gateColor(baseLongSetup))
    table.cell(dbg, 2, 1, textYesNo(baseShortSetup), bgcolor=gateColor(baseShortSetup))
    table.cell(dbg, 0, 2, "Session OK")
    table.cell(dbg, 1, 2, textYesNo(gateSessOK), bgcolor=gateColor(gateSessOK))
    table.cell(dbg, 2, 2, textYesNo(gateSessOK), bgcolor=gateColor(gateSessOK))
    table.cell(dbg, 0, 3, "ATR OK")
    table.cell(dbg, 1, 3, textYesNo(gateAtrOK), bgcolor=gateColor(gateAtrOK))
    table.cell(dbg, 2, 3, textYesNo(gateAtrOK), bgcolor=gateColor(gateAtrOK))
    table.cell(dbg, 0, 4, "HTF OK")
    table.cell(dbg, 1, 4, textYesNo(gateHTFLong), bgcolor=gateColor(gateHTFLong))
    table.cell(dbg, 2, 4, textYesNo(gateHTFShort), bgcolor=gateColor(gateHTFShort))
    table.cell(dbg, 0, 5, "Slope OK")
    table.cell(dbg, 1, 5, textYesNo(gateSlopeL), bgcolor=gateColor(gateSlopeL))
    table.cell(dbg, 2, 5, textYesNo(gateSlopeS), bgcolor=gateColor(gateSlopeS))
    table.cell(dbg, 0, 6, "ChopGuard OK")
    table.cell(dbg, 1, 6, textYesNo(cgOK), bgcolor=gateColor(cgOK))
    table.cell(dbg, 2, 6, textYesNo(cgOK), bgcolor=gateColor(cgOK))
    table.cell(dbg, 0, 7, "VWAP Side OK")
    table.cell(dbg, 1, 7, textYesNo(aboveVW), bgcolor=gateColor(aboveVW))
    table.cell(dbg, 2, 7, textYesNo(belowVW), bgcolor=gateColor(belowVW))
    table.cell(dbg, 0, 8, "EMA-Mid Side OK")
    table.cell(dbg, 1, 8, textYesNo(aboveEMAM or not requireEMAMSideBase), bgcolor=gateColor(aboveEMAM or not requireEMAMSideBase))
    table.cell(dbg, 2, 8, textYesNo(belowEMAM or not requireEMAMSideBase), bgcolor=gateColor(belowEMAM or not requireEMAMSideBase))
    table.cell(dbg, 0, 9, "Near VWAP OK")
    table.cell(dbg, 1, 9, textYesNo(nearAnyVWAP or not requireNearVWBase), bgcolor=gateColor(nearAnyVWAP or not requireNearVWBase))
    table.cell(dbg, 2, 9, textYesNo(nearAnyVWAP or not requireNearVWBase), bgcolor=gateColor(nearAnyVWAP or not requireNearVWBase))
    table.cell(dbg, 0, 10, "Vol Surge")
    table.cell(dbg, 1, 10, textYesNo(volSurge), bgcolor=gateColor(volSurge))
    table.cell(dbg, 2, 10, textYesNo(volSurge), bgcolor=gateColor(volSurge))
    table.cell(dbg, 0, 11, "Overextended?")
    table.cell(dbg, 1, 11, textYesNo(not overLong), bgcolor=gateColor(not overLong))
    table.cell(dbg, 2, 11, textYesNo(not overShort), bgcolor=gateColor(not overShort))
    table.cell(dbg, 0, 12, "CLV OK")
    table.cell(dbg, 1, 12, textYesNo(clvLongOK), bgcolor=gateColor(clvLongOK))
    table.cell(dbg, 2, 12, textYesNo(clvShortOK), bgcolor=gateColor(clvShortOK))
    table.cell(dbg, 0, 13, "KC Slope Guard")
    table.cell(dbg, 1, 13, "—")
    table.cell(dbg, 2, 13, textYesNo((not useKCSlopeGuard) or kcSlopeDown), bgcolor=gateColor((not useKCSlopeGuard) or kcSlopeDown))
    table.cell(dbg, 0, 14, "200-SMA Guard")
    table.cell(dbg, 1, 14, "—")
    table.cell(dbg, 2, 14, textYesNo((not useSMAGuard) or belowSMA), bgcolor=gateColor((not useSMAGuard) or belowSMA))
    table.cell(dbg, 0, 15, "Breakout Now")
    table.cell(dbg, 1, 15, textYesNo(breakoutLongNow), bgcolor=gateColor(breakoutLongNow))
    table.cell(dbg, 2, 15, textYesNo(breakoutShortNow), bgcolor=gateColor(breakoutShortNow))
    table.cell(dbg, 0, 16, "CONFIRMED")
    table.cell(dbg, 1, 16, textYesNo(longConfirm), bgcolor=gateColor(longConfirm))
    table.cell(dbg, 2, 16, textYesNo(shortConfirm), bgcolor=gateColor(shortConfirm))
    table.cell(dbg, 0, 17, "ATR ticks / Gate")
    table.cell(dbg, 1, 17, str.tostring(atrTicks) + " / " + str.tostring(minAtrTicks))

// latch cooldown when a new trade just opened
if barstate.isconfirmed and (longConfirm or shortConfirm)
    lastSignalBar := bar_index
    signalsToday += 1

// Plot arrows
plotshape(showSetups and baseLongSetup, title="Setup LONG", style=shape.triangleup, location=location.belowbar, color=color.new(color.lime, 40), size=size.tiny, text="setup")
plotshape(showSetups and baseShortSetup, title="Setup SHORT", style=shape.triangledown, location=location.abovebar, color=color.new(color.red, 40), size=size.tiny, text="setup")
plotshape(longConfirm, title="A+ LONG (confirmed)", style=shape.triangleup, location=location.belowbar, color=color.lime, size=size.large, text="A+ LONG")
plotshape(shortConfirm, title="A+ SHORT (confirmed)", style=shape.triangledown, location=location.abovebar, color=color.red, size=size.large, text="A+ SHORT")
bgcolor(longConfirm ? color.new(color.lime, 85) : shortConfirm ? color.new(color.red, 85) : na)

// A+ light
var label light = na
if barstate.islast
    if not na(light)
        label.delete(light)
    lightText = longConfirm ? "A+ LONG" : shortConfirm ? "A+ SHORT" : "NO A+"
    lightBg = longConfirm ? color.new(color.lime, 0) : shortConfirm ? color.new(color.red, 0) : color.new(color.gray, 80)
    light := label.new(bar_index, high, lightText, xloc=xloc.bar_index, yloc=yloc.abovebar, style=label.style_label_down, textcolor=color.black, color=lightBg, size=size.small)

// Alerts
alertcondition(enableAlerts and longConfirm, title="A+ LONG ENTRY", message="A+ LONG entry fired")
alertcondition(enableAlerts and shortConfirm, title="A+ SHORT ENTRY", message="A+ SHORT entry fired")
