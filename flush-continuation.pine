//@version=5
indicator("Flush Continuation", overlay=true, max_labels_count=500, max_lines_count=500)

// "A masterclass in momentum confluence — like ICT + Al Brooks + quant modeling had a baby."

// FlushMomentum model params (KEEP IN SYNC IN BOTH SCRIPTS)
// len1=40, len2=105, len3=170
// a0=-0.016711, a1=0.050736, a2=0.049021, a3=-0.092770, k=0.913499
// neutralBand / weakThresh = 3.0

// ========== Helpers ==========
slope(src, len) => (src - nz(src[len])) / len

// ========== Inputs ==========
groupCore   = "Core"
lenVol      = input.int(20, "Vol SMA", group=groupCore)
atrLen      = input.int(14, "ATR len", group=groupCore)
tfHTF       = input.string("15", "HTF (min) for ribbon", group=groupCore)

// --- Continuation thresholds (shared)
groupThresh = "Continuation Thresholds"
volMult     = input.float(1.5, "Vol thrust ≥ N × VolSMA", step=0.1, group=groupThresh)
roomATRMult = input.float(0.8, "Min room to ±3ATR (× ATR)", step=0.1, group=groupThresh)
impulseMult = input.float(1.0, "Impulse bar: (H−L) ≥ N×ATR", step=0.1, group=groupThresh)
barsLate    = input.int(6, "Too-late after cross (bars)", minval=1, group=groupThresh)

// --- Continuation weights (shared)
groupWeights = "Continuation Weights"
wHTF         = input.int(1, "HTF ribbon trend", minval=0, maxval=3, group=groupWeights)
wRibbon      = input.int(1, "LTF ribbon+slope+expansion", minval=0, maxval=3, group=groupWeights)
wVWAP        = input.int(1, "VWAP alignment", minval=0, maxval=3, group=groupWeights)
wRoom        = input.int(1, "Room to ±3ATR", minval=0, maxval=3, group=groupWeights)
wVolBody     = input.int(1, "Vol thrust + body position", minval=0, maxval=3, group=groupWeights)
wStruct      = input.int(1, "Structure break w/o reclaim", minval=0, maxval=3, group=groupWeights)
wMoxieRun    = input.int(1, "Moxie run proxy", minval=0, maxval=3, group=groupWeights)
wEMAGapAcc   = input.int(1, "EMA gap acceleration", minval=0, maxval=3, group=groupWeights)
wImpulse     = input.int(2, "Impulse bar", minval=0, maxval=3, group=groupWeights)
wEarlyBoost  = input.int(2, "Early-trigger boost", minval=0, maxval=3, group=groupWeights)

// --- Exhaustion penalties (shared)
groupNeg = "Exhaustion Penalties"
wTouchWick  = input.int(1, "Penalty: touch ±3ATR + long wick", minval=0, maxval=3, group=groupNeg)
wDiv        = input.int(1, "Penalty: divergence vs RSI", minval=0, maxval=3, group=groupNeg)
wTooLate    = input.int(1, "Penalty: cross too old", minval=0, maxval=3, group=groupNeg)

// --- Entry/Exit basic
groupSignals = "Entry/Exit Signals"
entryThresh  = input.int(5, "Entry score ≥", group=groupSignals)
exitThresh   = input.int(2, "Exit when continuation score ≤ (after entry)", group=groupSignals)
holdBarsMax  = input.int(60, "Hard cap bars in trade", group=groupSignals)
showOnlyOnCross = input.bool(true, "Show entry label only on cross bar", group=groupSignals)

// --- PCX (bottoms after 0↓) / PCT (tops after 0↑)
groupPX  = "Post-Cross Extremes (PCX/PCT)"
pxEnabled    = input.bool(true, "Enable PCX/PCT detectors", group=groupPX)
pxBarsWin    = input.int(10, "Base window after cross (bars)", minval=2, group=groupPX)
pxAdaptive   = input.bool(true, "ATR-adaptive window (7–12 bars)", group=groupPX)
pxVolMult    = input.float(1.6, "Vol spike ≥ N × VolSMA", step=0.1, group=groupPX)
pxWickMin    = input.float(0.45, "Wick ratio ≥ (extreme wick threshold)", step=0.01, group=groupPX)
pxThresh     = input.int(3, "Extreme score ≥ (label trigger)", minval=2, maxval=6, group=groupPX)
pxEarlyThresh= input.int(3, "EARLY EXIT when extreme score ≥", minval=2, maxval=6, group=groupPX)
closeOnEarly = input.bool(true, "Flatten on EARLY EXIT", group=groupPX)

// --- MOX timers from data study
groupMOX = "MOX (Mean Optimal Exit)"
minHoldShortBase = input.int(25, "Shorts after 0↓: min-hold bars", minval=1, group=groupMOX)
minHoldLongBase  = input.int(20, "Longs after 0↑: min-hold bars",  minval=1, group=groupMOX)
moxATRAdapt      = input.bool(true, "ATR adapt MOX (±20%/±10%)", group=groupMOX)
revThresh        = input.int(2, "Reversal Strength needed for early exit", minval=1, maxval=5, group=groupMOX)
// we still keep this if you ever want tiny offsets later (but it's no longer used for entry labels)
moxLabelOffsetAtr = input.float(0.6, "MOX label offset (× ATR)", minval=0.0, step=0.1, group=groupMOX)

// --- Timeframe Scaling (NEW)
groupScale = "Timeframe Scaling"
baselineTFmin = input.int(3, "Baseline timeframe (minutes)", minval=1, group=groupScale)  // tuned on 3m
scaleEnabled  = input.bool(true, "Auto-scale bar-based settings by timeframe", group=groupScale)

// --- TP/SL Advisor (MNQ Dynamic SL/TP 2.0) ---
groupTPSL = "TP/SL Advisor"
tpAdvisorEnabled   = input.bool(true,  "Enable TP/SL advisor", group=groupTPSL)
tpAtrTF            = input.string("3", "TP/SL ATR timeframe (min)", group=groupTPSL)
atrBaselineLen     = input.int(200,    "ATR baseline length (bars)", minval=20, group=groupTPSL)
// Base thresholds (used for Generic profile / hlines)
lowVolThreshold    = input.float(0.80, "Base low vol: ATR / baseline <",  step=0.05, group=groupTPSL)
highVolThreshold   = input.float(1.20, "Base high vol: ATR / baseline >=", step=0.05, group=groupTPSL)
// Profile for tuned MNQ / SPX behaviour
profileTPSL        = input.string("Auto", "ATR regime profile", options=["Auto","MNQ","SPX","Generic"], group=groupTPSL, tooltip="Auto: detect MNQ/SPX from symbol and use tuned thresholds (MNQ 1.10/2.00, SPX 0.8/1.2). Generic: use base thresholds above.")

// Mode: percent (crypto) vs points (futures)
tpMode = input.string("Auto", "TP/SL mode", options=["Auto","Points (futures)","Percent (crypto)"], group=groupTPSL)

// Percent baselines (for crypto majors only)
percentLowVol    = input.float(0.35, "Baseline Low vol TP/SL (%)",    step=0.05, group=groupTPSL)
percentNormalVol = input.float(0.50, "Baseline Normal vol TP/SL (%)", step=0.05, group=groupTPSL)
percentHighVol   = input.float(0.80, "Baseline High vol TP/SL (%)",   step=0.05, group=groupTPSL)

// MNQ Dynamic SL/TP 2.0 baselines (UPDATED: Calm 16/20, Trend 22/35, High-Vol 28/40)
mnqSlLowVol     = input.float(16.0, "MNQ Calm SL (Low ATR)",        step=0.25, group=groupTPSL)
mnqSlNormalVol  = input.float(22.0, "MNQ Trend SL (Normal ATR)",    step=0.25, group=groupTPSL)
mnqSlHighVol    = input.float(28.0, "MNQ High-Vol SL",              step=0.25, group=groupTPSL)

mnqTpLowVol     = input.float(20.0, "MNQ Calm TP (Low ATR)",        step=0.25, group=groupTPSL)
mnqTpNormalVol  = input.float(35.0, "MNQ Trend TP (Normal ATR)",    step=0.25, group=groupTPSL)
mnqTpHighVol    = input.float(40.0, "MNQ High-Vol TP",              step=0.25, group=groupTPSL)

mnqMicroSl1 = input.float(10.0, "MNQ Ultra-Calm SL (pts)",   step=0.25, group=groupTPSL)
mnqMicroTp1 = input.float(10.0, "MNQ Ultra-Calm TP (pts)",   step=0.25, group=groupTPSL)

mnqMicroSl2 = input.float(12.0, "MNQ Very Calm SL (pts)",    step=0.25, group=groupTPSL)
mnqMicroTp2 = input.float(12.0, "MNQ Very Calm TP (pts)",    step=0.25, group=groupTPSL)

mnqMicroSl3 = input.float(15.0, "MNQ Calm Scalper SL (pts)", step=0.25, group=groupTPSL)
mnqMicroTp3 = input.float(15.0, "MNQ Calm Scalper TP (pts)", step=0.25, group=groupTPSL)

// For non-MNQ futures, we still keep generic baselines (used as SL, TP=SL by default)
pointsLowVol    = input.float(15.0, "Baseline Low vol TP/SL (MNQ pts)",    step=0.25, group=groupTPSL)
pointsNormalVol = input.float(20.0, "Baseline Normal vol TP/SL (MNQ pts)", step=0.25, group=groupTPSL)
pointsHighVol   = input.float(30.0, "Baseline High vol TP/SL (MNQ pts)",   step=0.25, group=groupTPSL)

// Symbol-specific scaling (× MNQ baseline)
useSymbolScaling   = input.bool(true,  "Use symbol-specific TP/SL scaling", group=groupTPSL)
mnqScale           = input.float(1.0,  "MNQ scale (× MNQ baseline)", step=0.05, group=groupTPSL)
mesScale           = input.float(0.30, "MES scale (× MNQ baseline)", step=0.05, group=groupTPSL)
spxScale           = input.float(1.0,  "SPX scale (× MNQ baseline)", step=0.05, group=groupTPSL)
esScale            = input.float(1.0,  "ES scale (× MNQ baseline)",  step=0.05, group=groupTPSL)
otherScale         = input.float(1.0,  "Other symbols scale (× MNQ baseline)", step=0.05, group=groupTPSL)

// Sizing advisor
targetProfit          = input.float(250.0, "Target profit per trade ($)", step=25.0, group=groupTPSL)
useSizeAdvisor        = input.bool(true,   "Show contracts for target profit", group=groupTPSL)
dollarsPerPointOverride = input.float(0.0, "Override $/point (0 = auto)", step=0.5, group=groupTPSL)

// Account & leverage advisor for crypto
accountBalance   = input.float(200000.0, "Account balance ($)", step=100.0, group=groupTPSL)
riskPctBalance   = input.float(1.0, "Risk per trade (% bal)", step=0.25, group=groupTPSL)
useLevAdvisor    = input.bool(true, "Show leverage advisor (crypto)", group=groupTPSL)

// Display options
showTPSLOnLabels   = input.bool(false, "Show TP/SL suggestion on FCS labels", group=groupTPSL)
showTPSLHud        = input.bool(true,  "Show TP/SL HUD (corner table)",       group=groupTPSL)
show2RLine         = input.bool(true,  "Show TP line on entries (uses Rec TP)", group=groupTPSL)

// Debug options for ATR regime
debugAtrSeries = input.bool(false, "Debug: plot ATR & baseline", group=groupTPSL)
debugAtrRatio  = input.bool(false, "Debug: plot ATR ratio",      group=groupTPSL)

// --- Fast ATR override (recent-vol sanity check) ---
useFastAtrOverride = input.bool(true,  "Use fast ATR override (recent vol)", group=groupTPSL)
fastAtrBaselineLen = input.int(15,     "Fast ATR baseline length (bars)",    minval=10, group=groupTPSL)
fastHighConfirm    = input.float(1.25, "Fast ratio needed to CONFIRM High",  step=0.05, group=groupTPSL)
fastLowBlock       = input.float(0.9, "Fast ratio needed to AVOID Low (< blocks Low)", step=0.05, group=groupTPSL)

// --- Display & Logger
groupDisp = "Display"
minimalMode   = input.bool(false, "Minimal mode (show only MOX / EARLY / EXIT)", group=groupDisp)
showFCS       = input.bool(true,  "Show FCS labels", group=groupDisp)
showPCX       = input.bool(true,  "Show PCX labels", group=groupDisp)
showPCT       = input.bool(true,  "Show PCT labels", group=groupDisp)
showMOX       = input.bool(true,  "Show MOX labels", group=groupDisp)
showEARLY     = input.bool(true,  "Show EARLY EXIT labels", group=groupDisp)
showEXIT      = input.bool(true,  "Show EXIT labels", group=groupDisp)
// offsets for FCS and EXIT so they don’t stack
fcsLabelOffsetAtr  = input.float(1.0, "FCS label offset (× ATR)",  minval=0.0, step=0.1, group=groupDisp)
exitLabelOffsetAtr = input.float(0.8, "EXIT label offset (× ATR)", minval=0.0, step=0.1, group=groupDisp)

// Label rendering window + thin markers
labelLookbackBars = input.int(50000, "Label lookback (bars)", minval=100, group=groupDisp)
showAllHistory    = input.bool(false, "Show labels on full history", group=groupDisp, tooltip="ON draws labels across all available bars (uses label budget faster). OFF limits to recent window.")
showHistoryShapes = input.bool(true, "Show thin historical markers", group=groupDisp)

groupLog = "Event Logger"
logEnabled    = input.bool(false, "Show on-chart event log (table)", group=groupLog)
logRows       = input.int(8, "Rows to keep", minval=3, maxval=20, group=groupLog)

// --- Data logging for Simons-mode (CSV via alert) ---
groupData      = "Data Logging (Simons Mode)"
dataLogEnabled = input.bool(false, "Enable entry CSV alerts", group=groupData, tooltip="ON = one alert() per FCS entry with CSV row for offline analysis. Create a TradingView alert with 'Any alert() function call'.")
dataLogTag     = input.string("FLUSH", "Log tag prefix", group=groupData)

// ===== Logger vars + function =====
var table t = na
var int   logIdx = 0
var float NAf    = na

logDo(string _side, string _event, float _price, float _fcs, float _pxx, float _tcs_rss, int _idx) =>
    if logEnabled and not na(t)
        row = 1 + (_idx % logRows)
        table.cell(t, 0, row, str.tostring(bar_index))
        table.cell(t, 1, row, _side)
        table.cell(t, 2, row, _event)
        table.cell(t, 3, row, str.tostring(_price, format.mintick))
        table.cell(t, 4, row, na(_fcs) ? "" : str.tostring(_fcs))
        table.cell(t, 5, row, na(_pxx) ? "" : str.tostring(_pxx))
        table.cell(t, 6, row, na(_tcs_rss) ? "" : str.tostring(_tcs_rss))
    _idx + 1

// Apply minimal mode
_showFCS   = minimalMode ? false : showFCS
_showPCX   = minimalMode ? false : showPCX
_showPCT   = minimalMode ? false : showPCT
_showMOX   = showMOX or minimalMode
_showEARLY = showEARLY or minimalMode
_showEXIT  = showEXIT or minimalMode

// ===== Allow-labels gate (prevents spending label budget far back)
var int _lastIdx = na
if barstate.islast
    _lastIdx := bar_index
allowLabels = showAllHistory ? true : (na(_lastIdx) ? true : bar_index >= (_lastIdx - labelLookbackBars))

// ===== Timeframe multiplier (for barsLate / PCX window / MOX scaling)
tfMult = scaleEnabled and timeframe.isminutes ? (timeframe.multiplier * 1.0) / baselineTFmin : 1.0
barsLateScaled  = math.max(1, math.round(barsLate * tfMult))
pxBarsWinScaled = math.max(1, math.round(pxBarsWin * tfMult))

// --- Flush Momentum Filter (using recurrent oscillator)
groupFM       = "Flush Momentum Filter"
useFMFilter   = input.bool(true,  "Use FlushMomentum filter", group=groupFM)
fmLookback    = input.int(24,     "Bars for FlushMomentum trend baseline", minval=1, group=groupFM)
fmNeutralBand = input.float(3.0,  "Neutral band (|osc| ≤, treated as flat)", group=groupFM)
fmTrendStrength = input.float(0.55, "History trend fraction (0–1)", minval=0.34, maxval=1.0, step=0.01, group=groupFM)
fmUseSignGate = input.bool(false, "Require FlushMomentum to be above/below zero", group=groupFM, tooltip="If ON: shorts require osc<0 and longs osc>0. If OFF: use only trend + neutral band.")
fmSharpMult   = input.float(1.0,  "Sharp turn multiplier on strong threshold", group=groupFM, tooltip="Reserved for future tweaks.")
minFmStateBars = input.int(1, "Min bars FM state must persist", minval=0, group=groupFM)
showFMPlots   = input.bool(false, "Debug: plot FlushMomentum & Moxie proxy", group=groupFM)
showFMDots    = input.bool(false, "Show FM gate markers on chart", group=groupFM)

// ===== Recurrent FlushMomentum oscillator (local, no plots) =====
srcFM  = close
len1FM = 40
len2FM = 105
len3FM = 170

// Coeffs from export (recurrent model)
a0FM = -0.016711
a1FM =  0.050736
a2FM =  0.049021
a3FM = -0.092770
kFM  =  0.913499

ema1FM = ta.ema(srcFM, len1FM)
ema2FM = ta.ema(srcFM, len2FM)
ema3FM = ta.ema(srcFM, len3FM)

c_e1_FM  = srcFM  - ema1FM
e1_e2_FM = ema1FM - ema2FM
e2_e3_FM = ema2FM - ema3FM

base_step_FM = a0FM + a1FM * c_e1_FM + a2FM * e1_e2_FM + a3FM * e2_e3_FM

var float oscFM = na
oscFM := na(oscFM[1]) ? base_step_FM : base_step_FM + kFM * oscFM[1]

// Direction & neutral
fmIsNeutral = math.abs(oscFM) <= fmNeutralBand
fmSlopeUp   = oscFM > oscFM[1]
fmSlopeDown = oscFM < oscFM[1]
fmSlopeFlat = not fmSlopeUp and not fmSlopeDown

// Baseline for “overall trend”
fmBaseline = ta.sma(oscFM, fmLookback)

// 1-bar trend relative to baseline
fmTrendDownNow = fmSlopeDown and oscFM < fmBaseline
fmTrendUpNow   = fmSlopeUp   and oscFM > fmBaseline

// History trend: fraction of last fmLookback bars supporting each direction
fmTrendDownHist = ta.sma((oscFM < fmBaseline and not fmIsNeutral) ? 1.0 : 0.0, fmLookback)
fmTrendUpHist   = ta.sma((oscFM > fmBaseline and not fmIsNeutral) ? 1.0 : 0.0, fmLookback)

goodHistShort = fmTrendDownHist >= fmTrendStrength
goodHistLong  = fmTrendUpHist   >= fmTrendStrength

// Base conditions: strong one-bar trend + supportive history + not neutral
baseShort = fmTrendDownNow and goodHistShort and not fmIsNeutral
baseLong  = fmTrendUpNow   and goodHistLong  and not fmIsNeutral

// Option B: require slope in trade direction, block neutral/opposite
goodSlopeShort = fmSlopeDown and not fmSlopeUp
goodSlopeLong  = fmSlopeUp   and not fmSlopeDown

// Optional sign gating: only when you want osc above/below zero to matter
shortCondBase = fmUseSignGate ? (baseShort and oscFM < 0) : baseShort
longCondBase  = fmUseSignGate ? (baseLong  and oscFM > 0) : baseLong

shortCond = shortCondBase and goodSlopeShort
longCond  = longCondBase  and goodSlopeLong

// Raw FM gates (no age restriction yet)
fmGateShortRaw = not useFMFilter or shortCond
fmGateLongRaw  = not useFMFilter or longCond

// --- FM Trade Readiness Markers ---
showFMState = input.bool(true, "Show FM trade readiness markers", group=groupFM)

// Current regime:  1 = long allowed, -1 = short allowed, 0 = neither
currFmState =
     fmGateLongRaw  and not fmGateShortRaw ?  1 :
     fmGateShortRaw and not fmGateLongRaw  ? -1 :
     0

// Track state changes so we only mark transitions
var int fmState = 0
stateChanged = currFmState != fmState
fmState := currFmState

// Track how long we've been in the current FM state
var int fmStateAge = 0
fmStateAge := stateChanged ? 0 : fmStateAge + 1

// Final gates (require FM state to be "mature" for at least minFmStateBars)
fmGateShort = not useFMFilter or (shortCond and fmState == -1 and fmStateAge >= minFmStateBars)
fmGateLong  = not useFMFilter or (longCond  and fmState ==  1 and fmStateAge >= minFmStateBars)

fmLongReady  = stateChanged and currFmState ==  1
fmShortReady = stateChanged and currFmState == -1
fmNoTrade    = stateChanged and currFmState ==  0

// Markers on chart
plotshape(showFMState and fmLongReady,  title="FM Long Ready",  style=shape.circle, location=location.belowbar, size=size.tiny, color=color.new(color.lime, 0), text="FM→L")
plotshape(showFMState and fmShortReady, title="FM Short Ready", style=shape.circle, location=location.abovebar, size=size.tiny, color=color.new(color.red, 0),  text="FM→S")
plotshape(showFMState and fmNoTrade,    title="FM No-Trade",    style=shape.xcross, location=location.bottom,   size=size.tiny, color=color.new(color.gray, 50), text="FM×")

// ========== Core series ==========
ema8  = ta.ema(close, 8)
ema21 = ta.ema(close, 21)
ema34 = ta.ema(close, 34)

ribbonBear    = ema8 < ema21 and ema21 < ema34
ribbonBull    = ema8 > ema21 and ema21 > ema34
ribbonSlopeDn = slope(ema8,3) < 0 and slope(ema21,3) < 0 and slope(ema34,3) < 0
ribbonSlopeUp = slope(ema8,3) > 0 and slope(ema21,3) > 0 and slope(ema34,3) > 0

expandDn = (ema21 - ema8) > nz((ema21 - ema8)[1]) and (ema34 - ema21) > nz((ema34 - ema21)[1])
expandUp = (ema8 - ema21) > nz((ema8 - ema21)[1]) and (ema21 - ema34) > nz((ema21 - ema34)[1])

vwapSess  = ta.vwap(close)
atr       = ta.atr(atrLen)
atrMed    = ta.sma(atr, 200)

// Local ATR regime on the chart timeframe (for micro-vol sanity check)
atrBaselineLoc = ta.sma(atr, atrBaselineLen)
atrRatioLocal  = atrBaselineLoc > 0 ? atr / atrBaselineLoc : 1.0

// ===== ATR regime & TP/SL recommendation (POINTS, fixed TF) =====
atrHTF         = request.security(syminfo.tickerid, tpAtrTF, ta.atr(atrLen))
atrBaselineHTF = request.security(syminfo.tickerid, tpAtrTF, ta.sma(ta.atr(atrLen), atrBaselineLen))
atrRatio       = atrBaselineHTF > 0 ? atrHTF / atrBaselineHTF : 1.0

// Fast ATR baseline (shorter memory → reacts to recent calm/rip)
fastAtrBaselineHTF = request.security(syminfo.tickerid, tpAtrTF, ta.sma(ta.atr(atrLen), fastAtrBaselineLen))
fastAtrRatio = fastAtrBaselineHTF > 0 ? atrHTF / fastAtrBaselineHTF : 1.0

// Instrument detection for ATR profile + scaling
tickerUpper = str.upper(syminfo.ticker)
rootUpper   = str.upper(syminfo.root)

isMNQ = str.contains(tickerUpper, "MNQ") or rootUpper == "MNQ"
isSPX = str.contains(tickerUpper, "SPX") or rootUpper == "SPX"
isMES = str.contains(tickerUpper, "MES") or rootUpper == "MES"
isES  = str.contains(tickerUpper, "ES")  or rootUpper == "ES"

// --- CRYPTO VS FUTURES MODE (updated) ---
baseUpper = str.upper(syminfo.basecurrency)
isBTC = baseUpper == "BTC"
isETH = baseUpper == "ETH"
isSOL = baseUpper == "SOL"

// Treat only BTC/ETH/SOL as major crypto AND never treat MES as crypto
isMajorCrypto = (syminfo.type == "crypto") and (isBTC or isETH or isSOL) and not isMES

// Percent mode only if instrument is actually major crypto
usePercentMode =
     (tpMode == "Percent (crypto)" and isMajorCrypto) or
     (tpMode == "Auto"             and isMajorCrypto)

// Effective ATR thresholds
float effLow  = lowVolThreshold
float effHigh = highVolThreshold

if profileTPSL == "MNQ" or (profileTPSL == "Auto" and isMNQ)
    effLow  := 1.10
    effHigh := 2.00
else if profileTPSL == "SPX" or (profileTPSL == "Auto" and isSPX)
    effLow  := 0.80
    effHigh := 1.20
else if isMajorCrypto
    effLow  := 0.95
    effHigh := 1.40
// else: Generic → keep base thresholds

// --- Vol regime with fast ATR override ---
// 0 = low (Calm), 1 = normal (Trend), 2 = high (High-Vol)
int volRegimeCore =
     not tpAdvisorEnabled ? 1 :
     atrRatio < effLow  ? 0 :
     atrRatio > effHigh ? 2 :
                          1

if tpAdvisorEnabled and useFastAtrOverride
    // If slow ATR says HIGH but fast ratio isn't confirming, downgrade to Normal.
    if volRegimeCore == 2 and fastAtrRatio < fastHighConfirm
        volRegimeCore := 1

    // If slow ATR says LOW but fast ratio is not that depressed, treat as Normal.
    if volRegimeCore == 0 and fastAtrRatio > fastLowBlock
        volRegimeCore := 1

volRegime = volRegimeCore

volRegimeLabel =
     volRegime == 0 ? "Low" :
     volRegime == 2 ? "High" :
                      "Normal"

// Symbol-specific scaling factor (relative to MNQ baselines)
symScale =
     not useSymbolScaling ? 1.0 :
     isMNQ ? mnqScale :
     isMES ? mesScale :
     isSPX ? spxScale :
     isES  ? esScale  :
             otherScale

// Percent baselines
basePct =
     volRegime == 0 ? percentLowVol :
     volRegime == 2 ? percentHighVol :
                      percentNormalVol

// === Recs: SL & TP in points (futures) or % (crypto) ===
float recSlPoints = na
float recTpPoints = na
float recPoints   = na   // for backwards-compat (treated as TP distance)
float recPct      = na

// Tier label for HUD (MNQ micro-tier / generic)
string tierLabel = "n/a"

if usePercentMode
    // Crypto majors → SL/TP in percent; here SL=TP by default
    recPct      := basePct
    recPoints   := close * recPct / 100.0
    recSlPoints := recPoints
    recTpPoints := recPoints
    // For crypto we just mirror ATR regime label
    tierLabel   := volRegimeLabel
else
    // FUTURES MODE
    // 1) Pick baseline SL/TP in points (unscaled)
    float baseSlPts = na
    float baseTpPts = na

    if isMNQ
        // 1) ATR-based micro speed (HTF + local)
        float microVolRaw   = na(fastAtrRatio) ? atrRatio : fastAtrRatio
        float microVolLocal = na(atrRatioLocal) ? microVolRaw : math.min(microVolRaw, atrRatioLocal)
        float microVolAtr   = math.max(microVolLocal, 0.01)  // safety floor

        // 2) Range-based micro speed: how big are candles vs Calm Scalper TP (15 pts)
        float avgRange10 = ta.sma(high - low, 10)
        float rangeRatio = (not na(avgRange10) and mnqMicroTp3 > 0.0) ? (avgRange10 / mnqMicroTp3) : 1.0

        // Final micro-vol signal: respect BOTH ATR and absolute bar size
        float microVol = math.min(microVolAtr, rangeRatio)

        // === Unified MNQ ladder ===
        // If truly high vol, skip straight to High-Vol tier.
        if volRegime == 2
            baseSlPts := mnqSlHighVol
            baseTpPts := mnqTpHighVol
            tierLabel := "High-Vol"
        else
            // Non-high regimes (Low/Normal) → full micro ladder:
            // - Ultra-Calm    → 10/10   (tiny tape)
            // - Very Calm     → 12/12
            // - Calm Scalper  → 15/15
            // - Calm          → 16/20
            // - Trend         → 22/35
            if microVol <= 0.75
                baseSlPts := mnqMicroSl1
                baseTpPts := mnqMicroTp1
                tierLabel := "Ultra-Calm"
            else if microVol <= 0.90
                baseSlPts := mnqMicroSl2
                baseTpPts := mnqMicroTp2
                tierLabel := "Very Calm"
            else if microVol <= 1.05
                baseSlPts := mnqMicroSl3
                baseTpPts := mnqMicroTp3
                tierLabel := "Calm Scalper"
            else if microVol <= 1.30
                baseSlPts := mnqSlLowVol
                baseTpPts := mnqTpLowVol
                tierLabel := "Calm"
            else
                baseSlPts := mnqSlNormalVol
                baseTpPts := mnqTpNormalVol
                tierLabel := "Trend"
    else
        // Generic futures (MES, ES, SPX, etc) → 1:1 by default
        float genericBase =
             volRegime == 0 ? pointsLowVol :
             volRegime == 2 ? pointsHighVol :
                              pointsNormalVol
        baseSlPts := genericBase
        baseTpPts := genericBase
        tierLabel := volRegimeLabel

    // 2) Apply symbol scaling
    recSlPoints := baseSlPts * symScale
    recTpPoints := baseTpPts * symScale

    // For legacy downstream logic, treat recPoints as "TP distance"
    recPoints := recTpPoints
    recPct    := close > 0 ? (recPoints / close) * 100.0 : na

// === $/point + per-contract PnL & contracts for target ===
autoDollarsPerPoint =
     isMNQ ? 2.0 :
     isMES ? 5.0 :
     isES  ? 50.0 :
     isSPX ? 50.0 :
             1.0

dollarsPerPoint =
     dollarsPerPointOverride > 0 ? dollarsPerPointOverride : autoDollarsPerPoint

// Per contract PnL is based on TP distance
perContractPnL = not na(recPoints) ? recPoints * dollarsPerPoint : na

contractsForTargetRaw = (useSizeAdvisor and not na(perContractPnL) and perContractPnL > 0) ? (targetProfit / perContractPnL) : na
contractsForTarget    = not na(contractsForTargetRaw) ? math.ceil(contractsForTargetRaw) : na

// === MES-specific calculations (auto) ===
mesTickSize           = syminfo.mintick
mesTicks              = isMES and mesTickSize > 0 and not na(recPoints) ? recPoints / mesTickSize : na
mesDollarsPerContract = isMES ? perContractPnL : na

// === Crypto leverage & size advisor (for % mode) ===
riskDollarBal = accountBalance * riskPctBalance / 100.0
cryptoSlPct   = usePercentMode and isMajorCrypto ? recPct : na
slFrac        = not na(cryptoSlPct) and cryptoSlPct > 0 ? cryptoSlPct / 100.0 : na

notionalForRisk = not na(slFrac) and riskDollarBal > 0 ? riskDollarBal / slFrac : na
notionalForTP   = not na(slFrac) and targetProfit > 0 ? targetProfit / slFrac : na

levForRisk = not na(notionalForRisk) and accountBalance > 0 ? notionalForRisk / accountBalance : na
levForTP   = not na(notionalForTP)   and accountBalance > 0 ? notionalForTP   / accountBalance : na

sizeCoinsRisk = not na(notionalForRisk) and close > 0 ? notionalForRisk / close : na
sizeCoinsTP   = not na(notionalForTP)   and close > 0 ? notionalForTP   / close : na

// === TP/SL debug plots ===
plot(debugAtrSeries ? atrHTF         : na, title="ATR (HTF)",          color=color.new(color.orange, 0))
plot(debugAtrSeries ? atrBaselineHTF : na, title="ATR baseline (HTF)", color=color.new(color.teal,   0))
plot(debugAtrRatio  ? atrRatio       : na, title="ATR ratio",          color=color.new(color.yellow, 0))
plot(debugAtrRatio  ? fastAtrRatio   : na, title="Fast ATR ratio",     color=color.new(color.fuchsia, 0))
hline(lowVolThreshold,  "Low-vol threshold (base)",  color=color.new(color.green, 70))
hline(highVolThreshold, "High-vol threshold (base)", color=color.new(color.red,   70))

bandN3dn  = ema21 - 3.0 * atr     // −3 ATR
bandN2_5dn= ema21 - 2.5 * atr
bandP3up  = ema21 + 3.0 * atr     // +3 ATR
bandP2_5up= ema21 + 2.5 * atr

volThrust = volume / ta.sma(volume, lenVol) >= volMult
closePct  = (close - low) / math.max(high - low, 1e-6)
topWickPct= (high - close) / math.max(high - low, 1e-6)
bearBody  = closePct <= 0.30
bullBody  = topWickPct <= 0.30
impulse   = (high - low) >= impulseMult * atr

// Moxie proxy + crosses
moxieProxy     = ta.ema(close - ema34, 9)
moxieCrossUp   = ta.crossover(moxieProxy, 0)
moxieCrossDown = ta.crossunder(moxieProxy, 0)

// RSI & divergences
rsi = ta.rsi(close,14)
bullDiv = (close < close[5]) and (rsi > rsi[5])
bearDiv = (close > close[5]) and (rsi < rsi[5])

// === Cross ages
barsSinceDown = ta.barssince(moxieCrossDown)
barsSinceUp   = ta.barssince(moxieCrossUp)

// === Data logging helper (Simons-mode CSV row) ===
makeLogRow(_dir, _fcs, _barsSinceCross) =>
    dirVal = _dir
    tmin   = hour * 60 + minute

    // Ribbon state: 1 = strong bull, -1 = strong bear, 0 = mixed
    ribbonState =
         (ribbonBull and ribbonSlopeUp) ? 1 :
         (ribbonBear and ribbonSlopeDn) ? -1 : 0

    mSlope = slope(moxieProxy, 3)
    moxState =
         moxieProxy > 0 and mSlope > 0  ?  2 :
         moxieProxy > 0 and mSlope <= 0 ?  1 :
         moxieProxy < 0 and mSlope < 0  ? -2 : -1

    fmStateVal   = currFmState
    impVal       = impulse    ? 1 : 0
    volThrustVal = volThrust  ? 1 : 0
    vwapAlign    = (dirVal == 1 ? (close > vwapSess) : (close < vwapSess)) ? 1 : 0

    // time = UNIX ms of bar close. We'll parse in Python.
    tsStr = str.tostring(time)

    // Build CSV row
    dataLogTag + "," +
      syminfo.ticker + "," +
      timeframe.period + "," +
      tsStr + "," +
      str.tostring(bar_index) + "," +
      str.tostring(tmin) + "," +
      str.tostring(dirVal) + "," +
      str.tostring(volRegime) + "," +
      str.tostring(atrRatio, "#.###") + "," +
      str.tostring(fastAtrRatio, "#.###") + "," +
      tierLabel + "," +
      str.tostring(_fcs) + "," +
      str.tostring(_barsSinceCross) + "," +
      str.tostring(impVal) + "," +
      str.tostring(volThrustVal) + "," +
      str.tostring(ribbonState) + "," +
      str.tostring(vwapAlign) + "," +
      str.tostring(moxState) + "," +
      str.tostring(fmStateVal) + "," +
      str.tostring(close, format.mintick) + "," +
      str.tostring(recSlPoints, format.mintick) + "," +
      str.tostring(recTpPoints, format.mintick)

// ===== Continuation Scores (down & up) =====
fastDelta = ema21 - ema8
avgDelta  = ta.sma(fastDelta, 20)

// Shorts continuation (FCS↓)
earlyBoostDn = (moxieCrossDown or barsSinceDown <= 1) and fastDelta < avgDelta * 0.6 and (impulse and bearBody or volThrust and bearBody)
roomOKdn = (close - bandN3dn) >= roomATRMult * atr
fcsDn = 0
fcsDn += ribbonBear and ribbonSlopeDn and expandDn ? wRibbon : 0
fcsDn += slope(ema34,3) < 0 ? wHTF : 0
fcsDn += close < vwapSess ? wVWAP : 0
fcsDn += roomOKdn ? wRoom : 0
fcsDn += (volThrust and bearBody) ? wVolBody : 0
fcsDn += (close < ta.lowest(low,10)[1] and not (close > ta.lowest(low,10))) ? wStruct : 0
fcsDn += (moxieProxy < 0 and slope(moxieProxy,3) < 0) ? wMoxieRun : 0
fcsDn += ((ema21 - ema8) - nz((ema21 - ema8)[1]) + (ema34 - ema21) - nz((ema34 - ema21)[1]) > 0) ? wEMAGapAcc : 0
fcsDn += (impulse and bearBody) ? wImpulse : 0
fcsDn += earlyBoostDn ? wEarlyBoost : 0
tooLateDn = barsSinceDown > barsLateScaled
fcsDn -= (tooLateDn ? wTooLate : 0)
fcsDn -= ((close <= bandN3dn) and (low < bandN3dn) and closePct > 0.60) ? wTouchWick : 0
fcsDn -= bullDiv ? wDiv : 0

// Longs continuation (FCS↑)
earlyBoostUp = (moxieCrossUp or barsSinceUp <= 1) and fastDelta > avgDelta * (-0.6) and (impulse and bullBody or volThrust and bullBody)
roomOKup = (bandP3up - close) >= roomATRMult * atr
fcsUp = 0
fcsUp += ribbonBull and ribbonSlopeUp and expandUp ? wRibbon : 0
fcsUp += slope(ema34,3) > 0 ? wHTF : 0
fcsUp += close > vwapSess ? wVWAP : 0
fcsUp += roomOKup ? wRoom : 0
fcsUp += (volThrust and bullBody) ? wVolBody : 0
fcsUp += (close > ta.highest(high,10)[1] and not (close < ta.highest(high,10))) ? wStruct : 0
fcsUp += (moxieProxy > 0 and slope(moxieProxy,3) > 0) ? wMoxieRun : 0
fcsUp += ((ema8 - ema21) - nz((ema8 - ema21)[1]) + (ema21 - ema34) - nz((ema21 - ema34)[1]) > 0) ? wEMAGapAcc : 0
fcsUp += (impulse and bullBody) ? wImpulse : 0
fcsUp += earlyBoostUp ? wEarlyBoost : 0
tooLateUp = barsSinceUp > barsLateScaled
fcsUp -= (tooLateUp ? wTooLate : 0)
fcsUp -= ((close >= bandP3up) and (high > bandP3up) and topWickPct > 0.60) ? wTouchWick : 0
fcsUp -= bearDiv ? wDiv : 0

// ===== Entry labels (FCS only; TP/SL is in HUD table)
string fcsDnText = "FCS↓: " + str.tostring(fcsDn)
string fcsUpText = "FCS↑: " + str.tostring(fcsUp)

if showTPSLOnLabels and tpAdvisorEnabled
    string tpLine = ""
    if usePercentMode and not na(recPct)
        tpLine := "TP/SL: " + str.tostring(recPct, "#.##") + "% (" + volRegimeLabel + ")"
    else if not usePercentMode and not na(recSlPoints) and not na(recTpPoints)
        tpLine := "SL: " + str.tostring(recSlPoints, format.mintick) + " / TP: " + str.tostring(recTpPoints, format.mintick) + " (" + volRegimeLabel + ")"
    else
        tpLine := "TP/SL: " + str.tostring(recPoints, format.mintick) + " (" + volRegimeLabel + ")"
    if isMES and not na(mesTicks) and not na(mesDollarsPerContract)
        tpLine += "\nMES≈" + str.tostring(mesTicks, "#") + "t / $" + str.tostring(mesDollarsPerContract, "#")
    else if perContractPnL > 0 and not isMajorCrypto
        tpLine += "\n≈ $" + str.tostring(perContractPnL, "#") + " / ctr"
    fcsDnText += "\n" + tpLine
    fcsUpText += "\n" + tpLine

if allowLabels and _showFCS and (showOnlyOnCross ? moxieCrossDown : (moxieCrossDown or barsSinceDown <= 1)) and fcsDn >= entryThresh and fmGateShort
    float fcsShortY = high + atr * fcsLabelOffsetAtr
    label.new(bar_index, fcsShortY, fcsDnText, style = label.style_label_down, textcolor = color.white, color = color.new(color.red, 0))

if allowLabels and _showFCS and (showOnlyOnCross ? moxieCrossUp : (moxieCrossUp or barsSinceUp <= 1)) and fcsUp >= entryThresh and fmGateLong
    float fcsLongY = low - atr * fcsLabelOffsetAtr
    label.new(bar_index, fcsLongY, fcsUpText, style = label.style_label_up, textcolor = color.white, color = color.new(color.green, 0))

// ===== Extreme detectors (PCX bottom for shorts, PCT top for longs)
offMinus = math.max(1, math.round(3 * tfMult))
offPlus  = math.max(1, math.round(2 * tfMult))
dynWin   = pxAdaptive ? (atr > atrMed ? math.max(1, pxBarsWinScaled - offMinus) : pxBarsWinScaled + offPlus) : pxBarsWinScaled

withinPostDn  = pxEnabled and barsSinceDown >= 0 and barsSinceDown <= dynWin
pcx = 0
pcx += (withinPostDn and moxieProxy < 0 and slope(moxieProxy,3) > 0 and moxieProxy > moxieProxy[1]) ? 1 : 0
pcx += (withinPostDn and rsi < 35 and slope(rsi,3) > 0) ? 1 : 0
pcx += (withinPostDn and (volume / ta.sma(volume, lenVol) >= pxVolMult)) ? 1 : 0
pcx += (withinPostDn and ((low < bandN3dn) or (close <= bandN2_5dn)) and ((high - low) > 0 ? (close - low) / (high - low) > pxWickMin : false)) ? 1 : 0
pcx += (withinPostDn and ((close >= ema21 - 1.8*atr) or ta.crossover(close, ema8) or (close > vwapSess) or (close > high[1]) or (close > close[1] and close[1] > close[2]))) ? 1 : 0
if allowLabels and _showPCX and withinPostDn and pcx >= pxThresh
    label.new(bar_index, low, "PCX: " + str.tostring(pcx), style=label.style_label_up, textcolor=color.white, color=color.new(color.lime, 0))

withinPostUp  = pxEnabled and barsSinceUp >= 0 and barsSinceUp <= dynWin
pct = 0
pct += (withinPostUp and moxieProxy > 0 and slope(moxieProxy,3) < 0 and moxieProxy < moxieProxy[1]) ? 1 : 0
pct += (withinPostUp and rsi > 65 and slope(rsi,3) < 0) ? 1 : 0
pct += (withinPostUp and (volume / ta.sma(volume, lenVol) >= pxVolMult)) ? 1 : 0
pct += (withinPostUp and ((high > bandP3up) or (close >= bandP2_5up)) and ((high - low) > 0 ? (high - close) / (high - low) > pxWickMin : false)) ? 1 : 0
pct += (withinPostUp and ((close <= ema21 + 1.8*atr) or ta.crossunder(close, ema8) or (close < vwapSess) or (close < low[1]) or (close < close[1] and close[1] < close[2]))) ? 1 : 0
if allowLabels and _showPCT and withinPostUp and pct >= pxThresh
    label.new(bar_index, high, "PCT: " + str.tostring(pct), style=label.style_label_down, textcolor=color.white, color=color.new(color.orange, 0))

// ========== Position States ==========
var bool inShort = false
var int  barsShort = 0
var int  shortMOX  = 0

var bool inLong  = false
var int  barsLong = 0
var int  longMOX  = 0

var line tpLineShort = na
var line tpLineLong = na
var float entryPriceShort = na
var float entryPriceLong = na
var float entryRecPctShort = na
var float entryRecPctLong = na
var float entryRecPointsShort = na
var float entryRecPointsLong = na

// MOX helpers — scale min-hold by timeframe
getMinHoldShort() =>
    base = minHoldShortBase
    baseScaled = scaleEnabled ? math.round(base * tfMult) : base
    math.max(1, baseScaled)

getMinHoldLong() =>
    base = minHoldLongBase
    baseScaled = scaleEnabled ? math.round(base * tfMult) : base
    math.max(1, baseScaled)

// Enter states (gated by FlushMomentum)
// MOX labels back on the candle (high/low), not offset by ATR
if (barsSinceDown <= 2) and (fcsDn >= entryThresh) and fmGateShort
    inShort  := true
    barsShort:= 0
    shortMOX := getMinHoldShort()
    entryPriceShort := close
    entryRecPctShort := recPct
    entryRecPointsShort := recPoints
    if show2RLine and not na(entryRecPointsShort) and not na(entryRecPctShort)
        float tpShortPrice = usePercentMode ? entryPriceShort * (1.0 - (entryRecPctShort * 2.0) / 100.0) : entryPriceShort - entryRecPointsShort * 2.0
        if not na(tpLineShort)
            line.delete(tpLineShort)
        tpLineShort := line.new(bar_index, tpShortPrice, bar_index + 1, tpShortPrice, extend=extend.right, color=color.new(color.red, 40), style=line.style_dotted)
    if allowLabels and _showMOX
        label.new(bar_index, high, "MOX↓ set: " + str.tostring(shortMOX),
                  style=label.style_label_down, textcolor=color.white, color=color.new(color.red, 0))
    logIdx := logDo("SHORT", "ENTRY", close, fcsDn, NAf, NAf, logIdx)
    // DATA LOG: CSV alert for short entry
    if dataLogEnabled
        rowShort = makeLogRow(-1, fcsDn, barsSinceDown)
        alert(rowShort, alert.freq_once_per_bar_close)

if (barsSinceUp <= 2) and (fcsUp >= entryThresh) and fmGateLong
    inLong  := true
    barsLong:= 0
    longMOX := getMinHoldLong()
    entryPriceLong := close
    entryRecPctLong := recPct
    entryRecPointsLong := recPoints
    if show2RLine and not na(entryRecPointsLong) and not na(entryRecPctLong)
        float tpLongPrice = usePercentMode ? entryPriceLong * (1.0 + (entryRecPctLong * 2.0) / 100.0) : entryPriceLong + entryRecPointsLong * 2.0
        if not na(tpLineLong)
            line.delete(tpLineLong)
        tpLineLong := line.new(bar_index, tpLongPrice, bar_index + 1, tpLongPrice, extend=extend.right, color=color.new(color.green, 40), style=line.style_dotted)
    if allowLabels and _showMOX
        label.new(bar_index, low, "MOX↑ set: " + str.tostring(longMOX),
                  style=label.style_label_up, textcolor=color.white, color=color.new(color.green, 0))
    logIdx := logDo("LONG", "ENTRY", close, fcsUp, NAf, NAf, logIdx)
    // DATA LOG: CSV alert for long entry
    if dataLogEnabled
        rowLong = makeLogRow(1, fcsUp, barsSinceUp)
        alert(rowLong, alert.freq_once_per_bar_close)

// ===== Reversal Strength & Trend Continuation
tcsDown = 0
tcsDown += ribbonBear and ribbonSlopeDn ? 1 : 0
tcsDown += close < vwapSess ? 1 : 0
tcsDown += ((ema21 - ema8) - nz((ema21 - ema8)[1]) + (ema34 - ema21) - nz((ema34 - ema21)[1]) > 0) ? 1 : 0
tcsDown += (moxieProxy < 0 and slope(moxieProxy,3) < 0) ? 1 : 0

rssUpFromDown = 0
rssUpFromDown += pcx >= pxEarlyThresh ? 1 : 0
rssUpFromDown += ta.crossover(close, ema8) ? 1 : 0
rssUpFromDown += close > high[1] ? 1 : 0
rssUpFromDown += (close > close[1] and close[1] > close[2]) ? 1 : 0
rssUpFromDown += (rsi > 50 and slope(rsi,3) > 0) ? 1 : 0
rssUpFromDown += close >= ema21 - 2*atr ? 1 : 0

tcsUp = 0
tcsUp += ribbonBull and ribbonSlopeUp ? 1 : 0
tcsUp += close > vwapSess ? 1 : 0
tcsUp += ((ema8 - ema21) - nz((ema8 - ema21)[1]) + (ema21 - ema34) - nz((ema21 - ema34)[1]) > 0) ? 1 : 0
tcsUp += (moxieProxy > 0 and slope(moxieProxy,3) > 0) ? 1 : 0

rssDnFromUp = 0
rssDnFromUp += pct >= pxEarlyThresh ? 1 : 0
rssDnFromUp += ta.crossunder(close, ema8) ? 1 : 0
rssDnFromUp += close < low[1] ? 1 : 0
rssDnFromUp += (close < close[1] and close[1] < close[2]) ? 1 : 0
rssDnFromUp += (rsi < 50 and slope(rsi,3) < 0) ? 1 : 0
rssDnFromUp += close <= ema21 + 2*atr ? 1 : 0

// MOX labels at expiry
if allowLabels and _showMOX and inShort and barsShort == shortMOX
    label.new(bar_index, low, "MOX↓", style=label.style_label_up, textcolor=color.white, color=color.new(color.yellow, 0))
if allowLabels and _showMOX and inLong and barsLong == longMOX
    label.new(bar_index, high, "MOX↑", style=label.style_label_down, textcolor=color.white, color=color.new(color.yellow, 0))

// ===== EARLY EXIT
tcsStrongDn   = tcsDown >= 3
moxieStillDn  = slope(moxieProxy, 3) < 0 and moxieProxy < 0
deepBelow2ATR = (ema21 - 2.0*atr) - close > 0.4*atr

bodySize   = math.abs(close - open)
prevBody   = math.abs(close[1] - open[1])
ftlSecondPoke = low <= low[2]
ftlWeaker     = (bodySize < prevBody) and ((high - low) > 0 ? (close - low) / (high - low) > pxWickMin : false)
ftlVolOK      = volume <= volume[1]
ftlValid      = ftlSecondPoke and ftlWeaker and ftlVolOK

higherLow        = low > low[1]
twoClosesAbove8  = close > ema8 and close[1] > ema8
volDecay         = ta.sma(volume, 3) < ta.sma(volume, 20)

requiredRSSShort = revThresh + (tcsStrongDn ? 2 : 1)
minFracShort     = tcsStrongDn ? 0.70 : 0.50
allowEarlyShort  = inShort and barsShort >= math.floor(shortMOX * minFracShort)

earlyExitOkShort =
     allowEarlyShort and rssUpFromDown >= requiredRSSShort and ftlValid and higherLow and twoClosesAbove8 and volDecay

suppressEarlyShort = deepBelow2ATR and moxieStillDn and tcsStrongDn

if allowLabels and _showEARLY and inShort and earlyExitOkShort and not suppressEarlyShort
    label.new(bar_index, low, "EARLY EXIT↓", style=label.style_label_up, textcolor=color.white, color=color.new(color.teal, 0))
    logIdx := logDo("SHORT", "EARLY↓", close, fcsDn, NAf, tcsDown+rssUpFromDown, logIdx)
    if closeOnEarly
        inShort   := false
        barsShort := 0

tcsStrongUp   = tcsUp >= 3
moxieStillUp  = slope(moxieProxy, 3) > 0 and moxieProxy > 0
deepAbove2ATR = close - (ema21 + 2.0*atr) > 0.4*atr

bodySizeU     = math.abs(close - open)
prevBodyU     = math.abs(close[1] - open[1])
fthSecondPoke = high >= high[2]
fthWeaker     = (bodySizeU < prevBodyU) and ((high - close) / math.max(high - low, 1e-6) > pxWickMin)
fthVolOK      = volume <= volume[1]
fthValid      = fthSecondPoke and fthWeaker and fthVolOK

lowerHigh        = high < high[1]
twoClosesBelow8  = close < ema8 and close[1] < ema8
volDecayU        = ta.sma(volume, 3) < ta.sma(volume, 20)

requiredRSSLong = revThresh + (tcsStrongUp ? 2 : 1)
minFracLong     = tcsStrongUp ? 0.70 : 0.50
allowEarlyLong  = inLong and barsLong >= math.floor(longMOX * minFracLong)

earlyExitOkLong =
     allowEarlyLong and rssDnFromUp >= requiredRSSLong and fthValid and lowerHigh and twoClosesBelow8 and volDecayU

suppressEarlyLong = deepAbove2ATR and moxieStillUp and tcsStrongUp

if allowLabels and _showEARLY and inLong and earlyExitOkLong and not suppressEarlyLong
    label.new(bar_index, high, "EARLY EXIT↑", style=label.style_label_down, textcolor=color.white, color=color.new(color.teal, 0))
    logIdx := logDo("LONG", "EARLY↑", close, fcsUp, NAf, tcsUp+rssDnFromUp, logIdx)
    if closeOnEarly
        inLong   := false
        barsLong := 0

// ===== Final EXIT
exitShortAllowed = inShort and (barsShort >= shortMOX or tcsDown <= 1)
exitShortCond =
      (close > ema8) or (close > vwapSess) or bullDiv
   or ((low < bandN3dn) and ((close >= ema21 - 1.8*atr) or (close > high[1])))
   or (close > math.max(high[1], high[2])) or (fcsDn <= exitThresh) or (barsShort > holdBarsMax)
if allowLabels and _showEXIT and exitShortAllowed and exitShortCond
    float exitShortY = low - atr * exitLabelOffsetAtr
    label.new(bar_index, exitShortY, "EXIT↓", style=label.style_label_up, textcolor=color.white, color=color.new(color.lime, 0))
    logIdx := logDo("SHORT", "EXIT↓", close, fcsDn, NAf, tcsDown, logIdx)
    inShort   := false
    barsShort := 0

exitLongAllowed = inLong and (barsLong >= longMOX or tcsUp <= 1)
exitLongCond =
      (close < ema8) or (close < vwapSess) or bearDiv
   or ((high > bandP3up) and ((close <= ema21 + 2.0*atr) or (close < low[1])))
   or (close < math.min(low[1], low[2])) or (fcsUp <= exitThresh) or (barsLong > holdBarsMax)
if allowLabels and _showEXIT and exitLongAllowed and exitLongCond
    float exitLongY = high + atr * exitLabelOffsetAtr
    label.new(bar_index, exitLongY, "EXIT↑", style=label.style_label_down, textcolor=color.white, color=color.new(color.lime, 0))
    logIdx := logDo("LONG", "EXIT↑", close, fcsUp, NAf, tcsUp, logIdx)
    inLong   := false
    barsLong := 0

// ===== Timers
if inShort
    barsShort += 1
if inLong
    barsLong  += 1

// ===== Simple on-chart logger (table) — ring buffer (no shifting)
if logEnabled and na(t)
    t := table.new(position.top_right, 7, logRows + 1)
    table.cell(t, 0, 0, "Bar",   text_color=color.white, bgcolor=color.new(color.silver, 25))
    table.cell(t, 1, 0, "Side",  text_color=color.white, bgcolor=color.new(color.silver, 25))
    table.cell(t, 2, 0, "Event", text_color=color.white, bgcolor=color.new(color.silver, 25))
    table.cell(t, 3, 0, "Price", text_color=color.white, bgcolor=color.new(color.silver, 25))
    table.cell(t, 4, 0, "FCS",   text_color=color.white, bgcolor=color.new(color.silver, 25))
    table.cell(t, 5, 0, "PCX/PCT",text_color=color.white, bgcolor=color.new(color.silver, 25))
    table.cell(t, 6, 0, "TCS/RSS",text_color=color.white, bgcolor=color.new(color.silver, 25))

// ===== TP/SL HUD table (top-right) =====
var table tpTable = na
var int   tpRows  = 0

if tpAdvisorEnabled and showTPSLHud and barstate.islast
    bool showPerCtr  = not isMajorCrypto and not na(perContractPnL) and perContractPnL > 0
    bool showSizeRow = not isMajorCrypto and useSizeAdvisor and not na(contractsForTarget) and perContractPnL > 0
    bool showLevRows = useLevAdvisor and isMajorCrypto and usePercentMode and not na(slFrac)

    int rowsNeeded = 7
    rowsNeeded += showPerCtr  ? 1 : 0
    rowsNeeded += showSizeRow ? 1 : 0
    rowsNeeded += showLevRows ? 2 : 0

    if na(tpTable) or tpRows != rowsNeeded
        tpTable := table.new(position.top_right, 2, rowsNeeded)
        tpRows  := rowsNeeded
        table.cell(tpTable, 0, 0, "Metric", text_color=color.white, bgcolor=color.new(color.silver, 25))
        table.cell(tpTable, 1, 0, "Value",  text_color=color.white, bgcolor=color.new(color.silver, 25))

    int r = 1
    table.cell(tpTable, 0, r, "ATR regime", text_color=color.white)
    table.cell(tpTable, 1, r, volRegimeLabel + " (" + profileTPSL + ")", text_color=color.white)
    r += 1
    table.cell(tpTable, 0, r, "ATR (curr)", text_color=color.white)
    table.cell(tpTable, 1, r, str.tostring(atrHTF, format.mintick) + " (" + str.tostring(atrRatio, "#.##") + "×)", text_color=color.white)
    r += 1
    table.cell(tpTable, 0, r, "Fast ATR ratio", text_color=color.white)
    table.cell(tpTable, 1, r, str.tostring(fastAtrRatio, "#.##") + "×", text_color=color.white)
    r += 1
    // Tier row (Ultra-Calm / Very Calm / Calm Scalper / Calm / Trend / High-Vol / etc)
    table.cell(tpTable, 0, r, "TP/SL Tier", text_color=color.white)
    table.cell(tpTable, 1, r, tierLabel,    text_color=color.white)
    r += 1
    table.cell(tpTable, 0, r, "Rec SL / TP", text_color=color.white)
    string tpDisplay = ""
    if usePercentMode and not na(recPct)
        tpDisplay := str.tostring(recPct, "#.##") + "% (crypto mode)"
    else if not na(recSlPoints) and not na(recTpPoints)
        tpDisplay := "SL: " + str.tostring(recSlPoints, format.mintick) + " / TP: " + str.tostring(recTpPoints, format.mintick)
    else
        tpDisplay := "TP: " + str.tostring(recPoints, format.mintick)
    table.cell(tpTable, 1, r, tpDisplay, text_color=color.white)
    r += 1
    table.cell(tpTable, 0, r, "TP x2", text_color=color.white)
    string tp2RDisplay = "n/a"
    if not na(recPoints) and not na(recPct)
        if usePercentMode
            tp2RDisplay := str.tostring(recPct * 2.0, "#.##") + "% (~" + str.tostring(recPoints * 2.0, format.mintick) + ")"
        else
            tp2RDisplay := str.tostring(recPoints * 2.0, format.mintick) + " pts (~" + str.tostring(recPct * 2.0, "#.##") + "%)"
    table.cell(tpTable, 1, r, tp2RDisplay, text_color=color.white)
    r += 1

    if showPerCtr
        table.cell(tpTable, 0, r, "Per ctr PnL", text_color=color.white)
        if isMES and not na(mesTicks) and not na(mesDollarsPerContract)
            table.cell(tpTable, 1, r, str.tostring(recPoints, format.mintick) + " pts ≈ " + str.tostring(mesTicks, "#") + " t ≈ $" + str.tostring(mesDollarsPerContract, "#"), text_color=color.white)
        else
            table.cell(tpTable, 1, r, str.tostring(recPoints, format.mintick) + " pts ≈ $" + str.tostring(perContractPnL, "#"), text_color=color.white)
        r += 1

    if showSizeRow
        table.cell(tpTable, 0, r, "Size for $" + str.tostring(targetProfit, "#"), text_color=color.white)
        table.cell(tpTable, 1, r, "≈ " + str.tostring(contractsForTarget, "#") + " ctrs (@ $" + str.tostring(perContractPnL, "#") + "/ctr)", text_color=color.white)
        r += 1

    if showLevRows
        string levRiskStr = not na(levForRisk) and not na(sizeCoinsRisk) ? "L" + str.tostring(levForRisk, "#.##") + " (~" + str.tostring(sizeCoinsRisk, "#.###") + " " + baseUpper + ")" : ""
        string levTPStr   = not na(levForTP)   and not na(sizeCoinsTP)   ? "L" + str.tostring(levForTP, "#.##")   + " (~" + str.tostring(sizeCoinsTP, "#.###")   + " " + baseUpper + ")" : ""
        table.cell(tpTable, 0, r, "Lev for risk", text_color=color.white)
        table.cell(tpTable, 1, r, levRiskStr, text_color=color.white)
        r += 1
        table.cell(tpTable, 0, r, "Lev for $" + str.tostring(targetProfit, "#"), text_color=color.white)
        table.cell(tpTable, 1, r, levTPStr, text_color=color.white)
else if (not tpAdvisorEnabled or not showTPSLHud) and not na(tpTable)
    table.clear(tpTable, 0, 0, 1, tpRows > 0 ? tpRows - 1 : 0)

// ===== Thin historical markers (cheap, full-history context)
plotshape(showHistoryShapes and (moxieCrossDown and fcsDn >= entryThresh),  title="FCS↓ mark", style=shape.triangledown, location=location.abovebar, size=size.tiny, color=color.new(color.red, 0))
plotshape(showHistoryShapes and (moxieCrossUp   and fcsUp >= entryThresh),  title="FCS↑ mark", style=shape.triangleup,   location=location.belowbar, size=size.tiny, color=color.new(color.green, 0))

plotshape(showHistoryShapes and (withinPostDn and pcx >= pxThresh), title="PCX mark", style=shape.circle, location=location.belowbar, size=size.tiny, color=color.new(color.lime, 0))
plotshape(showHistoryShapes and (withinPostUp and pct >= pxThresh), title="PCT mark", style=shape.circle, location=location.abovebar, size=size.tiny, color=color.new(color.orange, 0))

// ===== FlushMomentum debug: plots & FM gate dots =====
plot(showFMPlots ? oscFM      : na, title="FlushMomentum osc",         color=color.new(color.orange, 0), linewidth=2)
plot(showFMPlots ? moxieProxy : na, title="Moxie proxy (EMA close−34)", color=color.new(color.aqua,   0), linewidth=1)

plotshape(showFMDots and fmGateShort, title="FM Gate Short", style=shape.circle,  location=location.abovebar, size=size.tiny, color=color.new(color.red, 0))
plotshape(showFMDots and fmGateLong,  title="FM Gate Long",  style=shape.circle,  location=location.belowbar, size=size.tiny, color=color.new(color.lime, 0))

// === Extra features for bot / logging ===
// Position of close relative to 21 EMA in ATR units (0 = at EMA21, 3 ≈ +3ATR, -3 ≈ -3ATR)
float bandPos = atr > 0 ? (close - ema21) / atr : 0.0

// Moxie 3-bar slope + state (same idea as makeLogRow)
float moxSlope3 = slope(moxieProxy, 3)
int   moxStateBot =
     moxieProxy > 0 and moxSlope3 > 0  ?  2 :
     moxieProxy > 0 and moxSlope3 <= 0 ?  1 :
     moxieProxy < 0 and moxSlope3 < 0  ? -2 : -1

// =====================================================================
// ============== INTRABAR BOT ALERTS (MNQ FLUSH ENTRIES) ==============
// =====================================================================

// Signal definitions aligned with your entry logic:
isFlushShort = (barsSinceDown <= 2) and (fcsDn >= entryThresh) and fmGateShort
isFlushLong  = (barsSinceUp   <= 2) and (fcsUp >= entryThresh) and fmGateLong

// Only fire on live bars (no historical spam)
bool is_live = barstate.isrealtime

// Per-bar alert guards so we don't spam multiple times per bar
var bool flushShortAlertFired = false
var bool flushLongAlertFired  = false

// Reset once per new bar
if barstate.isnew
    flushShortAlertFired := false
    flushLongAlertFired  := false

// ---- Helper for SL/TP prices based on recSlPoints / recTpPoints ----
getSlTpPrices(dir, entryPrice, slPts, tpPts) =>
    float slP = na
    float tpP = na
    if not na(entryPrice) and not na(slPts) and not na(tpPts)
        if dir == -1
            // Short: SL above, TP below
            slP := entryPrice + slPts
            tpP := entryPrice - tpPts
        else if dir == 1
            // Long: SL below, TP above
            slP := entryPrice - slPts
            tpP := entryPrice + tpPts
    [slP, tpP]

// ==================== SHORT ALERT ====================
if is_live and isFlushShort and not flushShortAlertFired
    flushShortAlertFired := true

    float slPts = na(recSlPoints) ? 0.0 : recSlPoints
    float tpPts = na(recTpPoints) ? 0.0 : recTpPoints
    [slPriceShort, tpPriceShort] = getSlTpPrices(-1, close, slPts, tpPts)

    string msgShort = "{" + '"tag":"' + dataLogTag + '","v":1,"symbol":"' + syminfo.ticker + '","tf":"' + timeframe.period + '","time":' + str.tostring(time) + ',"bar_index":' + str.tostring(bar_index) + ',"dir":-1,"price":' + str.tostring(close, format.mintick) + ',"sl_points":' + str.tostring(slPts, format.mintick) + ',"tp_points":' + str.tostring(tpPts, format.mintick) + ',"sl_price":' + (na(slPriceShort) ? "null" : str.tostring(slPriceShort, format.mintick)) + ',"tp_price":' + (na(tpPriceShort) ? "null" : str.tostring(tpPriceShort, format.mintick)) + ',"vol_regime":' + str.tostring(volRegime) + ',"tier":"' + tierLabel + '","atr":' + str.tostring(atr, format.mintick) + ',"atr_ratio":' + str.tostring(atrRatio, "#.###") + ',"fast_atr_ratio":' + str.tostring(fastAtrRatio, "#.###") + ',"fcs":' + str.tostring(fcsDn) + ',"bars_since_cross":' + str.tostring(barsSinceDown) + ',"mox_val":' + str.tostring(moxieProxy, format.mintick) + ',"mox_slope":' + str.tostring(moxSlope3, format.mintick) + ',"mox_state":' + str.tostring(moxStateBot) + ',"band_pos":' + str.tostring(bandPos, "#.###") + ',"fm_state":' + str.tostring(currFmState) + "}"

    alert(msgShort, alert.freq_once_per_bar)

// ==================== LONG ALERT =====================
if is_live and isFlushLong and not flushLongAlertFired
    flushLongAlertFired := true

    float slPtsL = na(recSlPoints) ? 0.0 : recSlPoints
    float tpPtsL = na(recTpPoints) ? 0.0 : recTpPoints
    [slPriceLong, tpPriceLong] = getSlTpPrices(1, close, slPtsL, tpPtsL)

    string msgLong = "{" + '"tag":"' + dataLogTag + '","v":1,"symbol":"' + syminfo.ticker + '","tf":"' + timeframe.period + '","time":' + str.tostring(time) + ',"bar_index":' + str.tostring(bar_index) + ',"dir":1,"price":' + str.tostring(close, format.mintick) + ',"sl_points":' + str.tostring(slPtsL, format.mintick) + ',"tp_points":' + str.tostring(tpPtsL, format.mintick) + ',"sl_price":' + (na(slPriceLong) ? "null" : str.tostring(slPriceLong, format.mintick)) + ',"tp_price":' + (na(tpPriceLong) ? "null" : str.tostring(tpPriceLong, format.mintick)) + ',"vol_regime":' + str.tostring(volRegime) + ',"tier":"' + tierLabel + '","atr":' + str.tostring(atr, format.mintick) + ',"atr_ratio":' + str.tostring(atrRatio, "#.###") + ',"fast_atr_ratio":' + str.tostring(fastAtrRatio, "#.###") + ',"fcs":' + str.tostring(fcsUp) + ',"bars_since_cross":' + str.tostring(barsSinceUp) + ',"mox_val":' + str.tostring(moxieProxy, format.mintick) + ',"mox_slope":' + str.tostring(moxSlope3, format.mintick) + ',"mox_state":' + str.tostring(moxStateBot) + ',"band_pos":' + str.tostring(bandPos, "#.###") + ',"fm_state":' + str.tostring(currFmState) + "}"
    
    alert(msgLong, alert.freq_once_per_bar)
