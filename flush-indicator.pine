//@version=5
indicator("Flush Continuation + Exit (Moxie 0-cross — both sides, profit-optimized + MOX)",
     overlay=true, max_labels_count=500, max_lines_count=500, max_bars_back=5000)

// ========== Helpers ==========
slope(src, len) => (src - nz(src[len])) / len

// ========== Inputs ==========
groupCore   = "Core"
lenVol      = input.int(20, "Vol SMA", group=groupCore)
atrLen      = input.int(14, "ATR len", group=groupCore)
tfHTF       = input.string("15", "HTF (min) for ribbon", group=groupCore)

// --- Continuation thresholds (shared)
groupThresh = "Continuation Thresholds"
volMult     = input.float(1.5, "Vol thrust ≥ N × VolSMA", step=0.1, group=groupThresh)
roomATRMult = input.float(0.8, "Min room to ±3ATR (× ATR)", step=0.1, group=groupThresh)
impulseMult = input.float(1.0, "Impulse bar: (H−L) ≥ N×ATR", step=0.1, group=groupThresh)
barsLate    = input.int(6, "Too-late after cross (bars)", minval=1, group=groupThresh)

// --- Continuation weights (shared)
groupWeights = "Continuation Weights"
wHTF         = input.int(1, "HTF ribbon trend", minval=0, maxval=3, group=groupWeights)
wRibbon      = input.int(1, "LTF ribbon+slope+expansion", minval=0, maxval=3, group=groupWeights)
wVWAP        = input.int(1, "VWAP alignment", minval=0, maxval=3, group=groupWeights)
wRoom        = input.int(1, "Room to ±3ATR", minval=0, maxval=3, group=groupWeights)
wVolBody     = input.int(1, "Vol thrust + body position", minval=0, maxval=3, group=groupWeights)
wStruct      = input.int(1, "Structure break w/o reclaim", minval=0, maxval=3, group=groupWeights)
wMoxieRun    = input.int(1, "Moxie run proxy", minval=0, maxval=3, group=groupWeights)
wEMAGapAcc   = input.int(1, "EMA gap acceleration", minval=0, maxval=3, group=groupWeights)
wImpulse     = input.int(2, "Impulse bar", minval=0, maxval=3, group=groupWeights)
wEarlyBoost  = input.int(2, "Early-trigger boost", minval=0, maxval=3, group=groupWeights)

// --- Exhaustion penalties (shared)
groupNeg = "Exhaustion Penalties"
wTouchWick  = input.int(1, "Penalty: touch ±3ATR + long wick", minval=0, maxval=3, group=groupNeg)
wDiv        = input.int(1, "Penalty: divergence vs RSI", minval=0, maxval=3, group=groupNeg)
wTooLate    = input.int(1, "Penalty: cross too old", minval=0, maxval=3, group=groupNeg)

// --- Entry/Exit basic
groupSignals = "Entry/Exit Signals"
entryThresh  = input.int(5, "Entry score ≥", group=groupSignals)
exitThresh   = input.int(2, "Exit when continuation score ≤ (after entry)", group=groupSignals)
holdBarsMax  = input.int(60, "Hard cap bars in trade", group=groupSignals)
showOnlyOnCross = input.bool(true, "Show entry label only on cross bar", group=groupSignals)

// --- PCX (bottoms after 0↓) / PCT (tops after 0↑)
groupPX  = "Post-Cross Extremes (PCX/PCT)"
pxEnabled    = input.bool(true, "Enable PCX/PCT detectors", group=groupPX)
pxBarsWin    = input.int(10, "Base window after cross (bars)", minval=2, group=groupPX)
pxAdaptive   = input.bool(true, "ATR-adaptive window (7–12 bars)", group=groupPX)
pxVolMult    = input.float(1.6, "Vol spike ≥ N × VolSMA", step=0.1, group=groupPX)
pxWickMin    = input.float(0.45, "Wick ratio ≥ (extreme wick threshold)", step=0.01, group=groupPX)
pxThresh     = input.int(3, "Extreme score ≥ (label trigger)", minval=2, maxval=6, group=groupPX)
pxEarlyThresh= input.int(3, "EARLY EXIT when extreme score ≥", minval=2, maxval=6, group=groupPX)
closeOnEarly = input.bool(true, "Flatten on EARLY EXIT", group=groupPX)

// --- MOX timers from data study
groupMOX = "MOX (Mean Optimal Exit)"
minHoldShortBase = input.int(25, "Shorts after 0↓: min-hold bars", minval=1, group=groupMOX)
minHoldLongBase  = input.int(20, "Longs after 0↑: min-hold bars",  minval=1, group=groupMOX)
moxATRAdapt      = input.bool(true, "ATR adapt MOX (±20%/±10%)", group=groupMOX)
revThresh        = input.int(2, "Reversal Strength needed for early exit", minval=1, maxval=5, group=groupMOX)

// --- Display & Logger
groupDisp = "Display"
minimalMode   = input.bool(false, "Minimal mode (show only MOX / EARLY / EXIT)", group=groupDisp)
showFCS       = input.bool(true,  "Show FCS labels", group=groupDisp)
showPCX       = input.bool(true,  "Show PCX labels", group=groupDisp)
showPCT       = input.bool(true,  "Show PCT labels", group=groupDisp)
showMOX       = input.bool(true,  "Show MOX labels", group=groupDisp)
showEARLY     = input.bool(true,  "Show EARLY EXIT labels", group=groupDisp)
showEXIT      = input.bool(true,  "Show EXIT labels", group=groupDisp)

groupLog = "Event Logger"
logEnabled    = input.bool(false, "Show on-chart event log (table)", group=groupLog)
logRows       = input.int(8, "Rows to keep", minval=3, maxval=20, group=groupLog)

// Apply minimal mode
_showFCS   = minimalMode ? false : showFCS
_showPCX   = minimalMode ? false : showPCX
_showPCT   = minimalMode ? false : showPCT
_showMOX   = showMOX or minimalMode
_showEARLY = showEARLY or minimalMode
_showEXIT  = showEXIT or minimalMode

// ===== Logger — declare first; pure function returns next index
var table t = na
var int logIdx = 0
var float NAf = na

logDo(string _side, string _event, float _price, float _fcs, float _pxx, float _tcs_rss, int _idx) =>
    if logEnabled and not na(t)
        row = 1 + (_idx % logRows)
        table.cell(t, 0, row, str.tostring(bar_index))
        table.cell(t, 1, row, _side)
        table.cell(t, 2, row, _event)
        table.cell(t, 3, row, str.tostring(_price, format.mintick))
        table.cell(t, 4, row, na(_fcs)     ? "" : str.tostring(_fcs))
        table.cell(t, 5, row, na(_pxx)     ? "" : str.tostring(_pxx))
        table.cell(t, 6, row, na(_tcs_rss) ? "" : str.tostring(_tcs_rss))
    _idx + 1

// ========== Core series ==========
ema8  = ta.ema(close, 8)
ema21 = ta.ema(close, 21)
ema34 = ta.ema(close, 34)

ribbonBear    = ema8 < ema21 and ema21 < ema34
ribbonBull    = ema8 > ema21 and ema21 > ema34
ribbonSlopeDn = slope(ema8,3) < 0 and slope(ema21,3) < 0 and slope(ema34,3) < 0
ribbonSlopeUp = slope(ema8,3) > 0 and slope(ema21,3) > 0 and slope(ema34,3) > 0

expandDn = (ema21 - ema8) > nz((ema21 - ema8)[1]) and (ema34 - ema21) > nz((ema34 - ema21)[1])
expandUp = (ema8 - ema21) > nz((ema8 - ema21)[1]) and (ema21 - ema34) > nz((ema21 - ema34)[1])

vwapSess  = ta.vwap(close)
atr       = ta.atr(atrLen)
atrMed    = ta.sma(atr, 200)

bandN3dn  = ema21 - 3.0 * atr     // −3 ATR
bandN2_5dn= ema21 - 2.5 * atr
bandP3up  = ema21 + 3.0 * atr     // +3 ATR
bandP2_5up= ema21 + 2.5 * atr

volThrust = volume / ta.sma(volume, lenVol) >= volMult
closePct  = (close - low) / math.max(high - low, 1e-6)
topWickPct= (high - close) / math.max(high - low, 1e-6)
bearBody  = closePct <= 0.30
bullBody  = topWickPct <= 0.30
impulse   = (high - low) >= impulseMult * atr

// Moxie proxy + crosses
moxieProxy     = ta.ema(close - ema34, 9)
moxieCrossUp   = ta.crossover(moxieProxy, 0)
moxieCrossDown = ta.crossunder(moxieProxy, 0)

// RSI & divergences
rsi = ta.rsi(close,14)
bullDiv = (close < close[5]) and (rsi > rsi[5])
bearDiv = (close > close[5]) and (rsi < rsi[5])

// === Cross ages
barsSinceDown = ta.barssince(moxieCrossDown)
barsSinceUp   = ta.barssince(moxieCrossUp)

// ===== Continuation Scores (down & up) =====
fastDelta = ema21 - ema8
avgDelta  = ta.sma(fastDelta, 20)

// Shorts continuation (FCS↓)
earlyBoostDn = (moxieCrossDown or barsSinceDown <= 1) and fastDelta < avgDelta * 0.6 and (impulse and bearBody or volThrust and bearBody)
roomOKdn = (close - bandN3dn) >= roomATRMult * atr
fcsDn = 0
fcsDn += ribbonBear and ribbonSlopeDn and expandDn ? wRibbon : 0
fcsDn += slope(ema34,3) < 0 ? wHTF : 0
fcsDn += close < vwapSess ? wVWAP : 0
fcsDn += roomOKdn ? wRoom : 0
fcsDn += (volThrust and bearBody) ? wVolBody : 0
fcsDn += (close < ta.lowest(low,10)[1] and not (close > ta.lowest(low,10))) ? wStruct : 0
fcsDn += (moxieProxy < 0 and slope(moxieProxy,3) < 0) ? wMoxieRun : 0
fcsDn += ((ema21 - ema8) - nz((ema21 - ema8)[1]) + (ema34 - ema21) - nz((ema34 - ema21)[1]) > 0) ? wEMAGapAcc : 0
fcsDn += (impulse and bearBody) ? wImpulse : 0
fcsDn += earlyBoostDn ? wEarlyBoost : 0
fcsDn -= ((close <= bandN3dn) and (low < bandN3dn) and closePct > 0.60) ? wTouchWick : 0
fcsDn -= bullDiv ? wDiv : 0
fcsDn -= (barsSinceDown > barsLate) ? wTooLate : 0

// Longs continuation (FCS↑)
earlyBoostUp = (moxieCrossUp or barsSinceUp <= 1) and fastDelta > avgDelta * (-0.6) and (impulse and bullBody or volThrust and bullBody)
roomOKup = (bandP3up - close) >= roomATRMult * atr
fcsUp = 0
fcsUp += ribbonBull and ribbonSlopeUp and expandUp ? wRibbon : 0
fcsUp += slope(ema34,3) > 0 ? wHTF : 0
fcsUp += close > vwapSess ? wVWAP : 0
fcsUp += roomOKup ? wRoom : 0
fcsUp += (volThrust and bullBody) ? wVolBody : 0
fcsUp += (close > ta.highest(high,10)[1] and not (close < ta.highest(high,10))) ? wStruct : 0
fcsUp += (moxieProxy > 0 and slope(moxieProxy,3) > 0) ? wMoxieRun : 0
fcsUp += ((ema8 - ema21) - nz((ema8 - ema21)[1]) + (ema21 - ema34) - nz((ema21 - ema34)[1]) > 0) ? wEMAGapAcc : 0
fcsUp += (impulse and bullBody) ? wImpulse : 0
fcsUp += earlyBoostUp ? wEarlyBoost : 0
fcsUp -= ((close >= bandP3up) and (high > bandP3up) and topWickPct > 0.60) ? wTouchWick : 0
fcsUp -= bearDiv ? wDiv : 0
fcsUp -= (barsSinceUp > barsLate) ? wTooLate : 0

// ===== Entry labels (respect toggles)
if _showFCS and (showOnlyOnCross ? moxieCrossDown : (moxieCrossDown or barsSinceDown <= 1)) and fcsDn >= entryThresh
    label.new(bar_index, high, "FCS↓: " + str.tostring(fcsDn), style=label.style_label_down, textcolor=color.white, color=color.new(color.red, 0))
if _showFCS and (showOnlyOnCross ? moxieCrossUp : (moxieCrossUp or barsSinceUp <= 1)) and fcsUp >= entryThresh
    label.new(bar_index, low,  "FCS↑: " + str.tostring(fcsUp), style=label.style_label_up,   textcolor=color.white, color=color.new(color.green, 0))

// ===== Extreme detectors (PCX bottom for shorts, PCT top for longs)
dynWin = pxAdaptive ? (atr > atrMed ?  math.max(7, pxBarsWin - 3) : math.min(12, pxBarsWin + 2)) : pxBarsWin

withinPostDn  = pxEnabled and barsSinceDown >= 0 and barsSinceDown <= dynWin
pcx = 0
pcx += (withinPostDn and moxieProxy < 0 and slope(moxieProxy,3) > 0 and moxieProxy > moxieProxy[1]) ? 1 : 0
pcx += (withinPostDn and rsi < 35 and slope(rsi,3) > 0) ? 1 : 0
pcx += (withinPostDn and (volume / ta.sma(volume, lenVol) >= pxVolMult)) ? 1 : 0
pcx += (withinPostDn and ((low < bandN3dn) or (close <= bandN2_5dn)) and ((high - low) > 0 ? (close - low) / (high - low) > pxWickMin : false)) ? 1 : 0
pcx += (withinPostDn and ((close >= ema21 - 1.8*atr) or ta.crossover(close, ema8) or (close > vwapSess) or (close > high[1]) or (close > close[1] and close[1] > close[2]))) ? 1 : 0
if _showPCX and withinPostDn and pcx >= pxThresh
    label.new(bar_index, low, "PCX: " + str.tostring(pcx), style=label.style_label_up, textcolor=color.white, color=color.new(color.lime, 0))

withinPostUp  = pxEnabled and barsSinceUp >= 0 and barsSinceUp <= dynWin
pct = 0
pct += (withinPostUp and moxieProxy > 0 and slope(moxieProxy,3) < 0 and moxieProxy < moxieProxy[1]) ? 1 : 0
pct += (withinPostUp and rsi > 65 and slope(rsi,3) < 0) ? 1 : 0
pct += (withinPostUp and (volume / ta.sma(volume, lenVol) >= pxVolMult)) ? 1 : 0
pct += (withinPostUp and ((high > bandP3up) or (close >= bandP2_5up)) and ((high - low) > 0 ? (high - close) / (high - low) > pxWickMin : false)) ? 1 : 0
pct += (withinPostUp and ((close <= ema21 + 1.8*atr) or ta.crossunder(close, ema8) or (close < vwapSess) or (close < low[1]) or (close < close[1] and close[1] < close[2]))) ? 1 : 0
if _showPCT and withinPostUp and pct >= pxThresh
    label.new(bar_index, high, "PCT: " + str.tostring(pct), style=label.style_label_down, textcolor=color.white, color=color.new(color.orange, 0))

// ========== Position States ==========
var bool inShort = false
var int  barsShort = 0
var int  shortMOX  = 0

var bool inLong  = false
var int  barsLong = 0
var int  longMOX  = 0

getMinHoldShort() =>
    base = minHoldShortBase
    adj  = moxATRAdapt ? (atr > atrMed ? math.round(base * 0.8) : math.round(base * 1.1)) : base
    math.max(1, adj)

getMinHoldLong() =>
    base = minHoldLongBase
    adj  = moxATRAdapt ? (atr > atrMed ? math.round(base * 0.8) : math.round(base * 1.1)) : base
    math.max(1, adj)

// Enter states
if (barsSinceDown <= 2) and (fcsDn >= entryThresh)
    inShort  := true
    barsShort:= 0
    shortMOX := getMinHoldShort()
    if _showMOX
        label.new(bar_index, high, "MOX↓ set: " + str.tostring(shortMOX), style=label.style_label_down, textcolor=color.white, color=color.new(color.red, 0))
    logIdx := logDo("SHORT", "ENTRY", close, fcsDn, pcx, NAf, logIdx)

if (barsSinceUp <= 2) and (fcsUp >= entryThresh)
    inLong  := true
    barsLong:= 0
    longMOX := getMinHoldLong()
    if _showMOX
        label.new(bar_index, low, "MOX↑ set: " + str.tostring(longMOX), style=label.style_label_up, textcolor=color.white, color=color.new(color.green, 0))
    logIdx := logDo("LONG", "ENTRY", close, fcsUp, NAf, NAf, logIdx)

// ===== Reversal Strength & Trend Continuation
tcsDown = 0
tcsDown += ribbonBear and ribbonSlopeDn ? 1 : 0
tcsDown += close < vwapSess ? 1 : 0
tcsDown += ((ema21 - ema8) - nz((ema21 - ema8)[1]) + (ema34 - ema21) - nz((ema34 - ema21)[1]) > 0) ? 1 : 0
tcsDown += (moxieProxy < 0 and slope(moxieProxy,3) < 0) ? 1 : 0

rssUpFromDown = 0
rssUpFromDown += pcx >= pxEarlyThresh ? 1 : 0
rssUpFromDown += ta.crossover(close, ema8) ? 1 : 0
rssUpFromDown += close > high[1] ? 1 : 0
rssUpFromDown += (close > close[1] and close[1] > close[2]) ? 1 : 0
rssUpFromDown += (rsi > 50 and slope(rsi,3) > 0) ? 1 : 0
rssUpFromDown += close >= ema21 - 2*atr ? 1 : 0

tcsUp = 0
tcsUp += ribbonBull and ribbonSlopeUp ? 1 : 0
tcsUp += close > vwapSess ? 1 : 0
tcsUp += ((ema8 - ema21) - nz((ema8 - ema21)[1]) + (ema21 - ema34) - nz((ema21 - ema34)[1]) > 0) ? 1 : 0
tcsUp += (moxieProxy > 0 and slope(moxieProxy,3) > 0) ? 1 : 0

rssDnFromUp = 0
rssDnFromUp += pct >= pxEarlyThresh ? 1 : 0
rssDnFromUp += ta.crossunder(close, ema8) ? 1 : 0
rssDnFromUp += close < low[1] ? 1 : 0
rssDnFromUp += (close < close[1] and close[1] < close[2]) ? 1 : 0
rssDnFromUp += (rsi < 50 and slope(rsi,3) < 0) ? 1 : 0
rssDnFromUp += close <= ema21 + 2*atr ? 1 : 0

// MOX labels
if _showMOX and inShort and barsShort == shortMOX
    label.new(bar_index, low, "MOX↓", style=label.style_label_up, textcolor=color.white, color=color.new(color.yellow, 0))
if _showMOX and inLong and barsLong == longMOX
    label.new(bar_index, high, "MOX↑", style=label.style_label_down, textcolor=color.white, color=color.new(color.yellow, 0))

// ===== EARLY EXIT (hardened)
// SHORTS
tcsStrongDn   = tcsDown >= 3
moxieStillDn  = slope(moxieProxy, 3) < 0 and moxieProxy < 0
deepBelow2ATR = (ema21 - 2.0*atr) - close > 0.4*atr

bodySize   = math.abs(close - open)
prevBody   = math.abs(close[1] - open[1])
ftlSecondPoke = low <= low[2]
ftlWeaker     = (bodySize < prevBody) and ((high - low) > 0 ? (close - low) / (high - low) > pxWickMin : false)
ftlVolOK      = volume <= volume[1]
ftlValid      = ftlSecondPoke and ftlWeaker and ftlVolOK

higherLow        = low > low[1]
twoClosesAbove8  = close > ema8 and close[1] > ema8
volDecay         = ta.sma(volume, 3) < ta.sma(volume, 20)

requiredRSSShort = revThresh + (tcsStrongDn ? 2 : 1)
minFracShort     = tcsStrongDn ? 0.70 : 0.50
allowEarlyShort  = inShort and barsShort >= math.floor(shortMOX * minFracShort)

earlyExitOkShort =
     allowEarlyShort
  and rssUpFromDown >= requiredRSSShort
  and ftlValid and higherLow and twoClosesAbove8 and volDecay

suppressEarlyShort = deepBelow2ATR and moxieStillDn and tcsStrongDn

if _showEARLY and inShort and earlyExitOkShort and not suppressEarlyShort
    label.new(bar_index, low, "EARLY EXIT↓", style=label.style_label_up, textcolor=color.white, color=color.new(color.teal, 0))
    logIdx := logDo("SHORT", "EARLY↓", close, fcsDn, pcx, tcsDown+rssUpFromDown, logIdx)
    if closeOnEarly
        inShort   := false
        barsShort := 0

// LONGS (mirror)
tcsStrongUp   = tcsUp >= 3
moxieStillUp  = slope(moxieProxy, 3) > 0 and moxieProxy > 0
deepAbove2ATR = close - (ema21 + 2.0*atr) > 0.4*atr

bodySizeU     = math.abs(close - open)
prevBodyU     = math.abs(close[1] - open[1])
fthSecondPoke = high >= high[2]
fthWeaker     = (bodySizeU < prevBodyU) and ((high - close) / math.max(high - low, 1e-6) > pxWickMin)
fthVolOK      = volume <= volume[1]
fthValid      = fthSecondPoke and fthWeaker and fthVolOK

lowerHigh        = high < high[1]
twoClosesBelow8  = close < ema8 and close[1] < ema8
volDecayU        = ta.sma(volume, 3) < ta.sma(volume, 20)

requiredRSSLong = revThresh + (tcsStrongUp ? 2 : 1)
minFracLong     = tcsStrongUp ? 0.70 : 0.50
allowEarlyLong  = inLong and barsLong >= math.floor(longMOX * minFracLong)

earlyExitOkLong =
     allowEarlyLong
  and rssDnFromUp >= requiredRSSLong
  and fthValid and lowerHigh and twoClosesBelow8 and volDecayU

suppressEarlyLong = deepAbove2ATR and moxieStillUp and tcsStrongUp

if _showEARLY and inLong and earlyExitOkLong and not suppressEarlyLong
    label.new(bar_index, high, "EARLY EXIT↑", style=label.style_label_down, textcolor=color.white, color=color.new(color.teal, 0))
    logIdx := logDo("LONG", "EARLY↑", close, fcsUp, pct, tcsUp+rssDnFromUp, logIdx)
    if closeOnEarly
        inLong   := false
        barsLong := 0

// ===== Final EXIT (confirmed) — allowed only after MOX unless TCS weakens
exitShortAllowed = inShort and (barsShort >= shortMOX or tcsDown <= 1)
exitShortCond =
      (close > ema8) or (close > vwapSess) or bullDiv
   or ((low < bandN3dn) and ((close >= ema21 - 1.8*atr) or (close > high[1])))
   or (close > math.max(high[1], high[2])) or (fcsDn <= exitThresh) or (barsShort > holdBarsMax)
if _showEXIT and exitShortAllowed and exitShortCond
    label.new(bar_index, low, "EXIT↓", style=label.style_label_up, textcolor=color.white, color=color.new(color.lime, 0))
    logIdx := logDo("SHORT", "EXIT↓", close, fcsDn, pcx, tcsDown, logIdx)
    inShort   := false
    barsShort := 0

exitLongAllowed = inLong and (barsLong >= longMOX or tcsUp <= 1)
exitLongCond =
      (close < ema8) or (close < vwapSess) or bearDiv
   or ((high > bandP3up) and ((close <= ema21 + 1.8*atr) or (close < low[1])))
   or (close < math.min(low[1], low[2])) or (fcsUp <= exitThresh) or (barsLong > holdBarsMax)
if _showEXIT and exitLongAllowed and exitLongCond
    label.new(bar_index, high, "EXIT↑", style=label.style_label_down, textcolor=color.white, color=color.new(color.lime, 0))
    logIdx := logDo("LONG", "EXIT↑", close, fcsUp, pct, tcsUp, logIdx)
    inLong   := false
    barsLong := 0

// ===== Timers
if inShort
    barsShort += 1
if inLong
    barsLong  += 1

// ===== Simple on-chart logger (table) — ring buffer (no shifting) =====
if logEnabled and na(t)
    t := table.new(position.top_right, 7, logRows + 1)
    table.cell(t, 0, 0, "Bar",   text_color=color.white, bgcolor=color.new(color.silver, 25))
    table.cell(t, 1, 0, "Side",  text_color=color.white, bgcolor=color.new(color.silver, 25))
    table.cell(t, 2, 0, "Event", text_color=color.white, bgcolor=color.new(color.silver, 25))
    table.cell(t, 3, 0, "Price", text_color=color.white, bgcolor=color.new(color.silver, 25))
    table.cell(t, 4, 0, "FCS",   text_color=color.white, bgcolor=color.new(color.silver, 25))
    table.cell(t, 5, 0, "PCX/PCT",text_color=color.white, bgcolor=color.new(color.silver, 25))
    table.cell(t, 6, 0, "TCS/RSS",text_color=color.white, bgcolor=color.new(color.silver, 25))
