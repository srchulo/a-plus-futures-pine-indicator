//@version=5
indicator("Flush Continuation + Exit (Moxie 0-cross — both sides, profit-optimized + MOX)",
     overlay=true, max_labels_count=500, max_lines_count=500)


// ========== Helpers ==========
slope(src, len) => (src - nz(src[len])) / len

// ========== Inputs ==========
groupCore   = "Core"
lenVol      = input.int(20, "Vol SMA", group=groupCore)
atrLen      = input.int(14, "ATR len", group=groupCore)
tfHTF       = input.string("15", "HTF (min) for ribbon", group=groupCore)

// --- Continuation thresholds (shared)
groupThresh = "Continuation Thresholds"
volMult     = input.float(1.5, "Vol thrust ≥ N × VolSMA", step=0.1, group=groupThresh)
roomATRMult = input.float(0.8, "Min room to ±3ATR (× ATR)", step=0.1, group=groupThresh)
impulseMult = input.float(1.0, "Impulse bar: (H−L) ≥ N×ATR", step=0.1, group=groupThresh)
barsLate    = input.int(6, "Too-late after cross (bars)", minval=1, group=groupThresh)

// --- Continuation weights (shared)
groupWeights = "Continuation Weights"
wHTF         = input.int(1, "HTF ribbon trend", minval=0, maxval=3, group=groupWeights)
wRibbon      = input.int(1, "LTF ribbon+slope+expansion", minval=0, maxval=3, group=groupWeights)
wVWAP        = input.int(1, "VWAP alignment", minval=0, maxval=3, group=groupWeights)
wRoom        = input.int(1, "Room to ±3ATR", minval=0, maxval=3, group=groupWeights)
wVolBody     = input.int(1, "Vol thrust + body position", minval=0, maxval=3, group=groupWeights)
wStruct      = input.int(1, "Structure break w/o reclaim", minval=0, maxval=3, group=groupWeights)
wMoxieRun    = input.int(1, "Moxie run proxy", minval=0, maxval=3, group=groupWeights)
wEMAGapAcc   = input.int(1, "EMA gap acceleration", minval=0, maxval=3, group=groupWeights)
wImpulse     = input.int(2, "Impulse bar", minval=0, maxval=3, group=groupWeights)
wEarlyBoost  = input.int(2, "Early-trigger boost", minval=0, maxval=3, group=groupWeights)

// --- Exhaustion penalties (shared)
groupNeg = "Exhaustion Penalties"
wTouchWick  = input.int(1, "Penalty: touch ±3ATR + long wick", minval=0, maxval=3, group=groupNeg)
wDiv        = input.int(1, "Penalty: divergence vs RSI", minval=0, maxval=3, group=groupNeg)
wTooLate    = input.int(1, "Penalty: cross too old", minval=0, maxval=3, group=groupNeg)

// --- Entry/Exit basic
groupSignals = "Entry/Exit Signals"
entryThresh  = input.int(5, "Entry score ≥", group=groupSignals)
exitThresh   = input.int(2, "Exit when continuation score ≤ (after entry)", group=groupSignals)
holdBarsMax  = input.int(60, "Hard cap bars in trade", group=groupSignals)
showOnlyOnCross = input.bool(true, "Show entry label only on cross bar", group=groupSignals)

// --- PCX (bottoms after 0↓) / PCT (tops after 0↑)
groupPX  = "Post-Cross Extremes (PCX/PCT)"
pxEnabled    = input.bool(true, "Enable PCX/PCT detectors", group=groupPX)
pxBarsWin    = input.int(10, "Base window after cross (bars)", minval=2, group=groupPX)
pxAdaptive   = input.bool(true, "ATR-adaptive window (7–12 bars)", group=groupPX)
pxVolMult    = input.float(1.6, "Vol spike ≥ N × VolSMA", step=0.1, group=groupPX)
pxWickMin    = input.float(0.45, "Wick ratio ≥ (extreme wick threshold)", step=0.01, group=groupPX)
pxThresh     = input.int(3, "Extreme score ≥ (label trigger)", minval=2, maxval=6, group=groupPX)
pxEarlyThresh= input.int(3, "EARLY EXIT when extreme score ≥", minval=2, maxval=6, group=groupPX)
closeOnEarly = input.bool(true, "Flatten on EARLY EXIT", group=groupPX)

// --- MOX timers from data study
groupMOX = "MOX (Mean Optimal Exit)"
minHoldShortBase = input.int(25, "Shorts after 0↓: min-hold bars", minval=1, group=groupMOX)
minHoldLongBase  = input.int(20, "Longs after 0↑: min-hold bars",  minval=1, group=groupMOX)
moxATRAdapt      = input.bool(true, "ATR adapt MOX (±20%/±10%)", group=groupMOX)
revThresh        = input.int(2, "Reversal Strength needed for early exit", minval=1, maxval=5, group=groupMOX)

// ========== Core series ==========
ema8  = ta.ema(close, 8)
ema21 = ta.ema(close, 21)
ema34 = ta.ema(close, 34)

ribbonBear    = ema8 < ema21 and ema21 < ema34
ribbonBull    = ema8 > ema21 and ema21 > ema34
ribbonSlopeDn = slope(ema8,3) < 0 and slope(ema21,3) < 0 and slope(ema34,3) < 0
ribbonSlopeUp = slope(ema8,3) > 0 and slope(ema21,3) > 0 and slope(ema34,3) > 0

expandDn = (ema21 - ema8) > nz((ema21 - ema8)[1]) and (ema34 - ema21) > nz((ema34 - ema21)[1])
expandUp = (ema8 - ema21) > nz((ema8 - ema21)[1]) and (ema21 - ema34) > nz((ema21 - ema34)[1])

vwapSess  = ta.vwap(close)
atr       = ta.atr(atrLen)
atrMed    = ta.sma(atr, 200)

bandN3dn  = ema21 - 3.0 * atr     // −3 ATR (bottom band)
bandN2_5dn= ema21 - 2.5 * atr
bandP3up  = ema21 + 3.0 * atr     // +3 ATR (top band)
bandP2_5up= ema21 + 2.5 * atr

volThrust = volume / ta.sma(volume, lenVol) >= volMult
closePct  = (close - low) / math.max(high - low, 1e-6)
topWickPct= (high - close) / math.max(high - low, 1e-6)
bearBody  = closePct <= 0.30
bullBody  = topWickPct <= 0.30
impulse   = (high - low) >= impulseMult * atr

// Moxie proxy + crosses
moxieProxy     = ta.ema(close - ema34, 9)
moxieCrossUp   = ta.crossover(moxieProxy, 0)
moxieCrossDown = ta.crossunder(moxieProxy, 0)

// RSI & divergences
rsi = ta.rsi(close,14)
bullDiv = (close < close[5]) and (rsi > rsi[5])
bearDiv = (close > close[5]) and (rsi < rsi[5])

// === Cross ages
barsSinceDown = ta.barssince(moxieCrossDown)
barsSinceUp   = ta.barssince(moxieCrossUp)

// ===== Continuation Scores (down & up) =====
fastDelta = ema21 - ema8
avgDelta  = ta.sma(fastDelta, 20)

// Shorts continuation (FCS↓)
earlyBoostDn = (moxieCrossDown or barsSinceDown <= 1) and fastDelta < avgDelta * 0.6 and (impulse and bearBody or volThrust and bearBody)
roomOKdn = (close - bandN3dn) >= roomATRMult * atr
fcsDn = 0
fcsDn += ribbonBear and ribbonSlopeDn and expandDn ? wRibbon : 0
fcsDn += slope(ema34,3) < 0 ? wHTF : 0
fcsDn += close < vwapSess ? wVWAP : 0
fcsDn += roomOKdn ? wRoom : 0
fcsDn += (volThrust and bearBody) ? wVolBody : 0
fcsDn += (close < ta.lowest(low,10)[1] and not (close > ta.lowest(low,10))) ? wStruct : 0
fcsDn += (moxieProxy < 0 and slope(moxieProxy,3) < 0) ? wMoxieRun : 0
fcsDn += ((ema21 - ema8) - nz((ema21 - ema8)[1]) + (ema34 - ema21) - nz((ema34 - ema21)[1]) > 0) ? wEMAGapAcc : 0
fcsDn += (impulse and bearBody) ? wImpulse : 0
fcsDn += earlyBoostDn ? wEarlyBoost : 0
fcsDn -= ((close <= bandN3dn) and (low < bandN3dn) and closePct > 0.60) ? wTouchWick : 0
fcsDn -= bullDiv ? wDiv : 0
fcsDn -= (barsSinceDown > barsLate) ? wTooLate : 0

// Longs continuation (FCS↑)
earlyBoostUp = (moxieCrossUp or barsSinceUp <= 1) and fastDelta > avgDelta * (-0.6) and (impulse and bullBody or volThrust and bullBody)
roomOKup = (bandP3up - close) >= roomATRMult * atr
fcsUp = 0
fcsUp += ribbonBull and ribbonSlopeUp and expandUp ? wRibbon : 0
fcsUp += slope(ema34,3) > 0 ? wHTF : 0
fcsUp += close > vwapSess ? wVWAP : 0
fcsUp += roomOKup ? wRoom : 0
fcsUp += (volThrust and bullBody) ? wVolBody : 0
fcsUp += (close > ta.highest(high,10)[1] and not (close < ta.highest(high,10))) ? wStruct : 0
fcsUp += (moxieProxy > 0 and slope(moxieProxy,3) > 0) ? wMoxieRun : 0
fcsUp += ((ema8 - ema21) - nz((ema8 - ema21)[1]) + (ema21 - ema34) - nz((ema21 - ema34)[1]) > 0) ? wEMAGapAcc : 0
fcsUp += (impulse and bullBody) ? wImpulse : 0
fcsUp += earlyBoostUp ? wEarlyBoost : 0
fcsUp -= ((close >= bandP3up) and (high > bandP3up) and topWickPct > 0.60) ? wTouchWick : 0
fcsUp -= bearDiv ? wDiv : 0
fcsUp -= (barsSinceUp > barsLate) ? wTooLate : 0

// ===== Entry labels (visual only)
if (showOnlyOnCross ? moxieCrossDown : (moxieCrossDown or barsSinceDown <= 1)) and fcsDn >= entryThresh
    label.new(bar_index, high, "FCS↓: " + str.tostring(fcsDn), style=label.style_label_down, textcolor=color.white, color=color.new(color.red, 0))
if (showOnlyOnCross ? moxieCrossUp : (moxieCrossUp or barsSinceUp <= 1)) and fcsUp >= entryThresh
    label.new(bar_index, low,  "FCS↑: " + str.tostring(fcsUp), style=label.style_label_up,   textcolor=color.white, color=color.new(color.green, 0))

// ===== Extreme detectors (PCX bottom for shorts, PCT top for longs)
dynWin = pxAdaptive ? (atr > atrMed ?  math.max(7, pxBarsWin - 3) : math.min(12, pxBarsWin + 2)) : pxBarsWin

// PCX (bottom after 0↓)
withinPostDn  = pxEnabled and barsSinceDown >= 0 and barsSinceDown <= dynWin
pcx = 0
pcx += (withinPostDn and moxieProxy < 0 and slope(moxieProxy,3) > 0 and moxieProxy > moxieProxy[1]) ? 1 : 0
pcx += (withinPostDn and rsi < 35 and slope(rsi,3) > 0) ? 1 : 0
pcx += (withinPostDn and (volume / ta.sma(volume, lenVol) >= pxVolMult)) ? 1 : 0
pcx += (withinPostDn and ((low < bandN3dn) or (close <= bandN2_5dn)) and ((high - low) > 0 ? (close - low) / (high - low) > pxWickMin : false)) ? 1 : 0
pcx += (withinPostDn and ((close >= ema21 - 1.8*atr) or ta.crossover(close, ema8) or (close > vwapSess) or (close > high[1]) or (close > close[1] and close[1] > close[2]))) ? 1 : 0
if withinPostDn and pcx >= pxThresh
    label.new(bar_index, low, "PCX: " + str.tostring(pcx), style=label.style_label_up, textcolor=color.white, color=color.new(color.lime, 0))

// PCT (top after 0↑)
withinPostUp  = pxEnabled and barsSinceUp >= 0 and barsSinceUp <= dynWin
pct = 0
pct += (withinPostUp and moxieProxy > 0 and slope(moxieProxy,3) < 0 and moxieProxy < moxieProxy[1]) ? 1 : 0
pct += (withinPostUp and rsi > 65 and slope(rsi,3) < 0) ? 1 : 0
pct += (withinPostUp and (volume / ta.sma(volume, lenVol) >= pxVolMult)) ? 1 : 0
pct += (withinPostUp and ((high > bandP3up) or (close >= bandP2_5up)) and ((high - low) > 0 ? (high - close) / (high - low) > pxWickMin : false)) ? 1 : 0
pct += (withinPostUp and ((close <= ema21 + 1.8*atr) or ta.crossunder(close, ema8) or (close < vwapSess) or (close < low[1]) or (close < close[1] and close[1] < close[2]))) ? 1 : 0
if withinPostUp and pct >= pxThresh
    label.new(bar_index, high, "PCT: " + str.tostring(pct), style=label.style_label_down, textcolor=color.white, color=color.new(color.orange, 0))

// ========== Position States (Short & Long tracked separately) ==========
var bool inShort = false
var int  barsShort = 0
var int  shortMOX  = 0

var bool inLong  = false
var int  barsLong = 0
var int  longMOX  = 0

getMinHoldShort() =>
    base = minHoldShortBase
    adj  = moxATRAdapt ? (atr > atrMed ? math.round(base * 0.8) : math.round(base * 1.1)) : base
    math.max(1, adj)

getMinHoldLong() =>
    base = minHoldLongBase
    adj  = moxATRAdapt ? (atr > atrMed ? math.round(base * 0.8) : math.round(base * 1.1)) : base
    math.max(1, adj)

// --- Enter Short on FCS↓ near cross
if (barsSinceDown <= 2) and (fcsDn >= entryThresh)
    inShort  := true
    barsShort:= 0
    shortMOX := getMinHoldShort()
    label.new(bar_index, high, "MOX↓ set: " + str.tostring(shortMOX), style=label.style_label_down, textcolor=color.white, color=color.new(color.red, 0))

// --- Enter Long on FCS↑ near cross (mirror)
if (barsSinceUp <= 2) and (fcsUp >= entryThresh)
    inLong  := true
    barsLong:= 0
    longMOX := getMinHoldLong()
    label.new(bar_index, low, "MOX↑ set: " + str.tostring(longMOX), style=label.style_label_up, textcolor=color.white, color=color.new(color.green, 0))

// ===== Reversal Strength & Trend Continuation (both sides)
tcsDown = 0
tcsDown += ribbonBear and ribbonSlopeDn ? 1 : 0
tcsDown += close < vwapSess ? 1 : 0
tcsDown += ((ema21 - ema8) - nz((ema21 - ema8)[1]) + (ema34 - ema21) - nz((ema34 - ema21)[1]) > 0) ? 1 : 0
tcsDown += (moxieProxy < 0 and slope(moxieProxy,3) < 0) ? 1 : 0

rssUpFromDown = 0
rssUpFromDown += pcx >= pxEarlyThresh ? 1 : 0
rssUpFromDown += ta.crossover(close, ema8) ? 1 : 0
rssUpFromDown += close > high[1] ? 1 : 0
rssUpFromDown += (close > close[1] and close[1] > close[2]) ? 1 : 0
rssUpFromDown += (rsi > 50 and slope(rsi,3) > 0) ? 1 : 0
rssUpFromDown += close >= ema21 - 2*atr ? 1 : 0

tcsUp = 0
tcsUp += ribbonBull and ribbonSlopeUp ? 1 : 0
tcsUp += close > vwapSess ? 1 : 0
tcsUp += ((ema8 - ema21) - nz((ema8 - ema21)[1]) + (ema21 - ema34) - nz((ema21 - ema34)[1]) > 0) ? 1 : 0
tcsUp += (moxieProxy > 0 and slope(moxieProxy,3) > 0) ? 1 : 0

rssDnFromUp = 0
rssDnFromUp += pct >= pxEarlyThresh ? 1 : 0
rssDnFromUp += ta.crossunder(close, ema8) ? 1 : 0
rssDnFromUp += close < low[1] ? 1 : 0
rssDnFromUp += (close < close[1] and close[1] < close[2]) ? 1 : 0
rssDnFromUp += (rsi < 50 and slope(rsi,3) < 0) ? 1 : 0
rssDnFromUp += close <= ema21 + 2*atr ? 1 : 0

// ===== MOX labels at timer
if inShort and barsShort == shortMOX
    label.new(bar_index, low, "MOX↓", style=label.style_label_up, textcolor=color.white, color=color.new(color.yellow, 0))
if inLong and barsLong == longMOX
    label.new(bar_index, high, "MOX↑", style=label.style_label_down, textcolor=color.white, color=color.new(color.yellow, 0))

// ===== EARLY EXIT (only with strong reversal & after 40% MOX)
allowEarlyShort = inShort and barsShort >= math.floor(shortMOX * 0.4) and rssUpFromDown >= revThresh
if allowEarlyShort
    label.new(bar_index, low, "EARLY EXIT↓", style=label.style_label_up, textcolor=color.white, color=color.new(color.teal, 0))
    if closeOnEarly
        inShort   := false
        barsShort := 0

allowEarlyLong = inLong and barsLong >= math.floor(longMOX * 0.4) and rssDnFromUp >= revThresh
if allowEarlyLong
    label.new(bar_index, high, "EARLY EXIT↑", style=label.style_label_down, textcolor=color.white, color=color.new(color.teal, 0))
    if closeOnEarly
        inLong   := false
        barsLong := 0

// ===== Final EXIT (confirmed) — allowed only after MOX unless TCS weakens
// Shorts
exitShortAllowed = inShort and (barsShort >= shortMOX or tcsDown <= 1)
exitShortCond =
      (close > ema8) or (close > vwapSess) or bullDiv
   or ((low < bandN3dn) and ((close >= ema21 - 1.8*atr) or (close > high[1])))
   or (close > math.max(high[1], high[2])) or (fcsDn <= exitThresh) or (barsShort > holdBarsMax)
if exitShortAllowed and exitShortCond
    label.new(bar_index, low, "EXIT↓", style=label.style_label_up, textcolor=color.white, color=color.new(color.lime, 0))
    inShort   := false
    barsShort := 0

// Longs
exitLongAllowed = inLong and (barsLong >= longMOX or tcsUp <= 1)
exitLongCond =
      (close < ema8) or (close < vwapSess) or bearDiv
   or ((high > bandP3up) and ((close <= ema21 + 1.8*atr) or (close < low[1])))
   or (close < math.min(low[1], low[2])) or (fcsUp <= exitThresh) or (barsLong > holdBarsMax)
if exitLongAllowed and exitLongCond
    label.new(bar_index, high, "EXIT↑", style=label.style_label_down, textcolor=color.white, color=color.new(color.lime, 0))
    inLong   := false
    barsLong := 0

// ===== Timers
if inShort
    barsShort += 1
if inLong
    barsLong  += 1
