//@version=5
indicator("Flush Continuation", overlay=true, max_labels_count=500, max_lines_count=500)

// "A masterclass in momentum confluence — like ICT + Al Brooks + quant modeling had a baby."

// FlushMomentum model params (KEEP IN SYNC IN BOTH SCRIPTS)
// len1=40, len2=105, len3=170
// a0=-0.016711, a1=0.050736, a2=0.049021, a3=-0.092770, k=0.913499
// neutralBand / weakThresh = 3.0

// ========== Helpers ==========
slope(src, len) => (src - nz(src[len])) / len

// ========== Inputs ==========
groupCore   = "Core"
lenVol      = input.int(20, "Vol SMA", group=groupCore)
atrLen      = input.int(14, "ATR len", group=groupCore)
tfHTF       = input.string("15", "HTF (min) for ribbon", group=groupCore)

// --- Continuation thresholds (shared)
groupThresh = "Continuation Thresholds"
volMult     = input.float(1.5, "Vol thrust ≥ N × VolSMA", step=0.1, group=groupThresh)
roomATRMult = input.float(0.8, "Min room to ±3ATR (× ATR)", step=0.1, group=groupThresh)
impulseMult = input.float(1.0, "Impulse bar: (H−L) ≥ N×ATR", step=0.1, group=groupThresh)
barsLate    = input.int(6, "Too-late after cross (bars)", minval=1, group=groupThresh)

// --- Continuation weights (shared)
groupWeights = "Continuation Weights"
wHTF         = input.int(1, "HTF ribbon trend", minval=0, maxval=3, group=groupWeights)
wRibbon      = input.int(1, "LTF ribbon+slope+expansion", minval=0, maxval=3, group=groupWeights)
wVWAP        = input.int(1, "VWAP alignment", minval=0, maxval=3, group=groupWeights)
wRoom        = input.int(1, "Room to ±3ATR", minval=0, maxval=3, group=groupWeights)
wVolBody     = input.int(1, "Vol thrust + body position", minval=0, maxval=3, group=groupWeights)
wStruct      = input.int(1, "Structure break w/o reclaim", minval=0, maxval=3, group=groupWeights)
wMoxieRun    = input.int(1, "Moxie run proxy", minval=0, maxval=3, group=groupWeights)
wEMAGapAcc   = input.int(1, "EMA gap acceleration", minval=0, maxval=3, group=groupWeights)
wImpulse     = input.int(2, "Impulse bar", minval=0, maxval=3, group=groupWeights)
wEarlyBoost  = input.int(2, "Early-trigger boost", minval=0, maxval=3, group=groupWeights)

// --- Exhaustion penalties (shared)
groupNeg = "Exhaustion Penalties"
wTouchWick  = input.int(1, "Penalty: touch ±3ATR + long wick", minval=0, maxval=3, group=groupNeg)
wDiv        = input.int(1, "Penalty: divergence vs RSI", minval=0, maxval=3, group=groupNeg)
wTooLate    = input.int(1, "Penalty: cross too old", minval=0, maxval=3, group=groupNeg)

// --- Entry/Exit basic
groupSignals = "Entry/Exit Signals"
entryThresh  = input.int(5, "Entry score ≥", group=groupSignals)
exitThresh   = input.int(2, "Exit when continuation score ≤ (after entry)", group=groupSignals)
holdBarsMax  = input.int(60, "Hard cap bars in trade", group=groupSignals)
showOnlyOnCross = input.bool(true, "Show entry label only on cross bar", group=groupSignals)

// --- PCX (bottoms after 0↓) / PCT (tops after 0↑)
groupPX  = "Post-Cross Extremes (PCX/PCT)"
pxEnabled    = input.bool(true, "Enable PCX/PCT detectors", group=groupPX)
pxBarsWin    = input.int(10, "Base window after cross (bars)", minval=2, group=groupPX)
pxAdaptive   = input.bool(true, "ATR-adaptive window (7–12 bars)", group=groupPX)
pxVolMult    = input.float(1.6, "Vol spike ≥ N × VolSMA", step=0.1, group=groupPX)
pxWickMin    = input.float(0.45, "Wick ratio ≥ (extreme wick threshold)", step=0.01, group=groupPX)
pxThresh     = input.int(3, "Extreme score ≥ (label trigger)", minval=2, maxval=6, group=groupPX)
pxEarlyThresh= input.int(3, "EARLY EXIT when extreme score ≥", minval=2, maxval=6, group=groupPX)
closeOnEarly = input.bool(true, "Flatten on EARLY EXIT", group=groupPX)

// --- MOX timers from data study
groupMOX = "MOX (Mean Optimal Exit)"
minHoldShortBase = input.int(25, "Shorts after 0↓: min-hold bars", minval=1, group=groupMOX)
minHoldLongBase  = input.int(20, "Longs after 0↑: min-hold bars",  minval=1, group=groupMOX)
moxATRAdapt      = input.bool(true, "ATR adapt MOX (±20%/±10%)", group=groupMOX)
revThresh        = input.int(2, "Reversal Strength needed for early exit", minval=1, maxval=5, group=groupMOX)

// --- Timeframe Scaling (NEW)
groupScale = "Timeframe Scaling"
baselineTFmin = input.int(3, "Baseline timeframe (minutes)", minval=1, group=groupScale)  // tuned on 3m
scaleEnabled  = input.bool(true, "Auto-scale bar-based settings by timeframe", group=groupScale)

// --- Display & Logger
groupDisp = "Display"
minimalMode   = input.bool(false, "Minimal mode (show only MOX / EARLY / EXIT)", group=groupDisp)
showFCS       = input.bool(true,  "Show FCS labels", group=groupDisp)
showPCX       = input.bool(true,  "Show PCX labels", group=groupDisp)
showPCT       = input.bool(true,  "Show PCT labels", group=groupDisp)
showMOX       = input.bool(true,  "Show MOX labels", group=groupDisp)
showEARLY     = input.bool(true,  "Show EARLY EXIT labels", group=groupDisp)
showEXIT      = input.bool(true,  "Show EXIT labels", group=groupDisp)

// Label rendering window + thin markers
labelLookbackBars = input.int(50000, "Label lookback (bars)", minval=100, group=groupDisp)
showAllHistory    = input.bool(false, "Show labels on full history", group=groupDisp,
     tooltip="ON draws labels across all available bars (uses label budget faster). OFF limits to recent window.")
showHistoryShapes = input.bool(true, "Show thin historical markers", group=groupDisp)

groupLog = "Event Logger"
logEnabled    = input.bool(false, "Show on-chart event log (table)", group=groupLog)
logRows       = input.int(8, "Rows to keep", minval=3, maxval=20, group=groupLog)

// ===== Logger vars + function =====
var table t = na
var int   logIdx = 0
var float NAf    = na

logDo(string _side, string _event, float _price, float _fcs, float _pxx, float _tcs_rss, int _idx) =>
    if logEnabled and not na(t)
        row = 1 + (_idx % logRows)
        table.cell(t, 0, row, str.tostring(bar_index))
        table.cell(t, 1, row, _side)
        table.cell(t, 2, row, _event)
        table.cell(t, 3, row, str.tostring(_price, format.mintick))
        table.cell(t, 4, row, na(_fcs)     ? "" : str.tostring(_fcs))
        table.cell(t, 5, row, na(_pxx)     ? "" : str.tostring(_pxx))
        table.cell(t, 6, row, na(_tcs_rss) ? "" : str.tostring(_tcs_rss))
    _idx + 1

// Apply minimal mode
_showFCS   = minimalMode ? false : showFCS
_showPCX   = minimalMode ? false : showPCX
_showPCT   = minimalMode ? false : showPCT
_showMOX   = showMOX or minimalMode
_showEARLY = showEARLY or minimalMode
_showEXIT  = showEXIT or minimalMode

// ===== Allow-labels gate (prevents spending label budget far back)
var int _lastIdx = na
if barstate.islast
    _lastIdx := bar_index
allowLabels = showAllHistory ? true : (na(_lastIdx) ? true : bar_index >= (_lastIdx - labelLookbackBars))

// ===== Timeframe multiplier (for barsLate / PCX window / MOX scaling)
tfMult = scaleEnabled and timeframe.isminutes ? (timeframe.multiplier * 1.0) / baselineTFmin : 1.0
barsLateScaled  = math.max(1, math.round(barsLate * tfMult))
pxBarsWinScaled = math.max(1, math.round(pxBarsWin * tfMult))

// --- Flush Momentum Filter (using recurrent oscillator)
groupFM       = "Flush Momentum Filter"
useFMFilter   = input.bool(true,  "Use FlushMomentum filter",                 group=groupFM)
fmLookback    = input.int(6,      "Bars for FlushMomentum trend baseline",    minval=1, group=groupFM)
fmNeutralBand = input.float(3.0,  "Neutral band (|osc| ≤, treated as flat)",  group=groupFM)
fmTrendStrength = input.float(0.35, "History trend fraction (0–1)",           minval=0.34, maxval=1.0, step=0.01, group=groupFM)
fmUseSignGate = input.bool(false, "Require FlushMomentum to be above/below zero", group=groupFM, tooltip="If ON: shorts require osc<0 and longs osc>0. If OFF: use only trend + neutral band.")
fmSharpMult   = input.float(1.0,  "Sharp turn multiplier on strong threshold", group=groupFM, tooltip="Reserved for future tweaks.")
showFMPlots   = input.bool(false, "Debug: plot FlushMomentum & Moxie proxy",  group=groupFM)
showFMDots    = input.bool(false, "Show FM gate markers on chart",            group=groupFM)

// ===== Recurrent FlushMomentum oscillator (local, no plots) =====
srcFM  = close
len1FM = 40
len2FM = 105
len3FM = 170

// Coeffs from export (recurrent model)
a0FM = -0.016711
a1FM =  0.050736
a2FM =  0.049021
a3FM = -0.092770
kFM  =  0.913499

ema1FM = ta.ema(srcFM, len1FM)
ema2FM = ta.ema(srcFM, len2FM)
ema3FM = ta.ema(srcFM, len3FM)

c_e1_FM  = srcFM  - ema1FM
e1_e2_FM = ema1FM - ema2FM
e2_e3_FM = ema2FM - ema3FM

base_step_FM = a0FM + a1FM * c_e1_FM + a2FM * e1_e2_FM + a3FM * e2_e3_FM

var float oscFM = na
oscFM := na(oscFM[1]) ? base_step_FM : base_step_FM + kFM * oscFM[1]

// Direction & neutral
fmIsNeutral = math.abs(oscFM) <= fmNeutralBand
fmSlopeUp   = oscFM > oscFM[1]
fmSlopeDown = oscFM < oscFM[1]
fmSlopeFlat = not fmSlopeUp and not fmSlopeDown

// Baseline for “overall trend”
fmBaseline = ta.sma(oscFM, fmLookback)

// 1-bar trend relative to baseline
fmTrendDownNow = fmSlopeDown and oscFM < fmBaseline
fmTrendUpNow   = fmSlopeUp   and oscFM > fmBaseline

// History trend: fraction of last fmLookback bars supporting each direction
fmTrendDownHist = ta.sma((oscFM < fmBaseline and not fmIsNeutral) ? 1.0 : 0.0, fmLookback)
fmTrendUpHist   = ta.sma((oscFM > fmBaseline and not fmIsNeutral) ? 1.0 : 0.0, fmLookback)

goodHistShort = fmTrendDownHist >= fmTrendStrength
goodHistLong  = fmTrendUpHist   >= fmTrendStrength

// Base conditions: strong one-bar trend + supportive history + not neutral
baseShort = fmTrendDownNow and goodHistShort and not fmIsNeutral
baseLong  = fmTrendUpNow   and goodHistLong  and not fmIsNeutral

// Option B: require slope in trade direction, block neutral/opposite
goodSlopeShort = fmSlopeDown and not fmSlopeUp
goodSlopeLong  = fmSlopeUp   and not fmSlopeDown

// Optional sign gating: only when you want osc above/below zero to matter
shortCondBase = fmUseSignGate ? (baseShort and oscFM < 0) : baseShort
longCondBase  = fmUseSignGate ? (baseLong  and oscFM > 0) : baseLong

shortCond = shortCondBase and goodSlopeShort
longCond  = longCondBase  and goodSlopeLong

// Final gates (if filter disabled, always true)
fmGateShort = not useFMFilter or shortCond
fmGateLong  = not useFMFilter or longCond

// --- FM Trade Readiness Markers ---
showFMState = input.bool(true, "Show FM trade readiness markers", group=groupFM)

// Current regime:  1 = long allowed, -1 = short allowed, 0 = neither
currFmState =
     fmGateLong  and not fmGateShort ?  1 :
     fmGateShort and not fmGateLong  ? -1 :
     0

// Track state changes so we only mark transitions
var int fmState = 0
stateChanged = currFmState != fmState
fmState := currFmState

fmLongReady  = stateChanged and currFmState ==  1
fmShortReady = stateChanged and currFmState == -1
fmNoTrade    = stateChanged and currFmState ==  0

// Markers on chart
plotshape(showFMState and fmLongReady,
          title="FM Long Ready",
          style=shape.circle,
          location=location.belowbar,
          size=size.tiny,
          color=color.new(color.lime, 0),
          text="FM→L")

plotshape(showFMState and fmShortReady,
          title="FM Short Ready",
          style=shape.circle,
          location=location.abovebar,
          size=size.tiny,
          color=color.new(color.red, 0),
          text="FM→S")

plotshape(showFMState and fmNoTrade,
          title="FM No-Trade",
          style=shape.xcross,
          location=location.bottom,
          size=size.tiny,
          color=color.new(color.gray, 50),
          text="FM×")

// ========== Core series ==========
ema8  = ta.ema(close, 8)
ema21 = ta.ema(close, 21)
ema34 = ta.ema(close, 34)

ribbonBear    = ema8 < ema21 and ema21 < ema34
ribbonBull    = ema8 > ema21 and ema21 > ema34
ribbonSlopeDn = slope(ema8,3) < 0 and slope(ema21,3) < 0 and slope(ema34,3) < 0
ribbonSlopeUp = slope(ema8,3) > 0 and slope(ema21,3) > 0 and slope(ema34,3) > 0

expandDn = (ema21 - ema8) > nz((ema21 - ema8)[1]) and (ema34 - ema21) > nz((ema34 - ema21)[1])
expandUp = (ema8 - ema21) > nz((ema8 - ema21)[1]) and (ema21 - ema34) > nz((ema21 - ema34)[1])

vwapSess  = ta.vwap(close)
atr       = ta.atr(atrLen)
atrMed    = ta.sma(atr, 200)

bandN3dn  = ema21 - 3.0 * atr     // −3 ATR
bandN2_5dn= ema21 - 2.5 * atr
bandP3up  = ema21 + 3.0 * atr     // +3 ATR
bandP2_5up= ema21 + 2.5 * atr

volThrust = volume / ta.sma(volume, lenVol) >= volMult
closePct  = (close - low) / math.max(high - low, 1e-6)
topWickPct= (high - close) / math.max(high - low, 1e-6)
bearBody  = closePct <= 0.30
bullBody  = topWickPct <= 0.30
impulse   = (high - low) >= impulseMult * atr

// Moxie proxy + crosses
moxieProxy     = ta.ema(close - ema34, 9)
moxieCrossUp   = ta.crossover(moxieProxy, 0)
moxieCrossDown = ta.crossunder(moxieProxy, 0)

// RSI & divergences
rsi = ta.rsi(close,14)
bullDiv = (close < close[5]) and (rsi > rsi[5])
bearDiv = (close > close[5]) and (rsi < rsi[5])

// === Cross ages
barsSinceDown = ta.barssince(moxieCrossDown)
barsSinceUp   = ta.barssince(moxieCrossUp)

// ===== Continuation Scores (down & up) =====
fastDelta = ema21 - ema8
avgDelta  = ta.sma(fastDelta, 20)

// Shorts continuation (FCS↓)
earlyBoostDn = (moxieCrossDown or barsSinceDown <= 1) and fastDelta < avgDelta * 0.6 and (impulse and bearBody or volThrust and bearBody)
roomOKdn = (close - bandN3dn) >= roomATRMult * atr
fcsDn = 0
fcsDn += ribbonBear and ribbonSlopeDn and expandDn ? wRibbon : 0
fcsDn += slope(ema34,3) < 0 ? wHTF : 0
fcsDn += close < vwapSess ? wVWAP : 0
fcsDn += roomOKdn ? wRoom : 0
fcsDn += (volThrust and bearBody) ? wVolBody : 0
fcsDn += (close < ta.lowest(low,10)[1] and not (close > ta.lowest(low,10))) ? wStruct : 0
fcsDn += (moxieProxy < 0 and slope(moxieProxy,3) < 0) ? wMoxieRun : 0
fcsDn += ((ema21 - ema8) - nz((ema21 - ema8)[1]) + (ema34 - ema21) - nz((ema34 - ema21)[1]) > 0) ? wEMAGapAcc : 0
fcsDn += (impulse and bearBody) ? wImpulse : 0
fcsDn += earlyBoostDn ? wEarlyBoost : 0
// scaled "too late" penalty
tooLateDn = barsSinceDown > barsLateScaled
fcsDn -= (tooLateDn ? wTooLate : 0)
fcsDn -= ((close <= bandN3dn) and (low < bandN3dn) and closePct > 0.60) ? wTouchWick : 0
fcsDn -= bullDiv ? wDiv : 0

// Longs continuation (FCS↑)
earlyBoostUp = (moxieCrossUp or barsSinceUp <= 1) and fastDelta > avgDelta * (-0.6) and (impulse and bullBody or volThrust and bullBody)
roomOKup = (bandP3up - close) >= roomATRMult * atr
fcsUp = 0
fcsUp += ribbonBull and ribbonSlopeUp and expandUp ? wRibbon : 0
fcsUp += slope(ema34,3) > 0 ? wHTF : 0
fcsUp += close > vwapSess ? wVWAP : 0
fcsUp += roomOKup ? wRoom : 0
fcsUp += (volThrust and bullBody) ? wVolBody : 0
fcsUp += (close > ta.highest(high,10)[1] and not (close < ta.highest(high,10))) ? wStruct : 0
fcsUp += (moxieProxy > 0 and slope(moxieProxy,3) > 0) ? wMoxieRun : 0
fcsUp += ((ema8 - ema21) - nz((ema8 - ema21)[1]) + (ema21 - ema34) - nz((ema21 - ema34)[1]) > 0) ? wEMAGapAcc : 0
fcsUp += (impulse and bullBody) ? wImpulse : 0
fcsUp += earlyBoostUp ? wEarlyBoost : 0
// scaled "too late" penalty
tooLateUp = barsSinceUp > barsLateScaled
fcsUp -= (tooLateUp ? wTooLate : 0)
fcsUp -= ((close >= bandP3up) and (high > bandP3up) and topWickPct > 0.60) ? wTouchWick : 0
fcsUp -= bearDiv ? wDiv : 0

// ===== Entry labels (now gated by FlushMomentum)
if allowLabels
  and _showFCS
  and (showOnlyOnCross ? moxieCrossDown : (moxieCrossDown or barsSinceDown <= 1))
  and fcsDn >= entryThresh
  and fmGateShort
    label.new(bar_index, high, "FCS↓: " + str.tostring(fcsDn), style=label.style_label_down, textcolor=color.white, color=color.new(color.red, 0))

if allowLabels
  and _showFCS
  and (showOnlyOnCross ? moxieCrossUp : (moxieCrossUp or barsSinceUp <= 1))
  and fcsUp >= entryThresh
  and fmGateLong
    label.new(bar_index, low,  "FCS↑: " + str.tostring(fcsUp), style=label.style_label_up,   textcolor=color.white, color=color.new(color.green, 0))

// ===== Extreme detectors (PCX bottom for shorts, PCT top for longs)
offMinus = math.max(1, math.round(3 * tfMult))
offPlus  = math.max(1, math.round(2 * tfMult))
dynWin   = pxAdaptive
     ? (atr > atrMed ? math.max(1, pxBarsWinScaled - offMinus) : pxBarsWinScaled + offPlus)
     : pxBarsWinScaled

withinPostDn  = pxEnabled and barsSinceDown >= 0 and barsSinceDown <= dynWin
pcx = 0
pcx += (withinPostDn and moxieProxy < 0 and slope(moxieProxy,3) > 0 and moxieProxy > moxieProxy[1]) ? 1 : 0
pcx += (withinPostDn and rsi < 35 and slope(rsi,3) > 0) ? 1 : 0
pcx += (withinPostDn and (volume / ta.sma(volume, lenVol) >= pxVolMult)) ? 1 : 0
pcx += (withinPostDn and ((low < bandN3dn) or (close <= bandN2_5dn)) and ((high - low) > 0 ? (close - low) / (high - low) > pxWickMin : false)) ? 1 : 0
pcx += (withinPostDn and ((close >= ema21 - 1.8*atr) or ta.crossover(close, ema8) or (close > vwapSess) or (close > high[1]) or (close > close[1] and close[1] > close[2]))) ? 1 : 0
if allowLabels and _showPCX and withinPostDn and pcx >= pxThresh
    label.new(bar_index, low, "PCX: " + str.tostring(pcx), style=label.style_label_up, textcolor=color.white, color=color.new(color.lime, 0))

withinPostUp  = pxEnabled and barsSinceUp >= 0 and barsSinceUp <= dynWin
pct = 0
pct += (withinPostUp and moxieProxy > 0 and slope(moxieProxy,3) < 0 and moxieProxy < moxieProxy[1]) ? 1 : 0
pct += (withinPostUp and rsi > 65 and slope(rsi,3) < 0) ? 1 : 0
pct += (withinPostUp and (volume / ta.sma(volume, lenVol) >= pxVolMult)) ? 1 : 0
pct += (withinPostUp and ((high > bandP3up) or (close >= bandP2_5up)) and ((high - low) > 0 ? (high - close) / (high - low) > pxWickMin : false)) ? 1 : 0
pct += (withinPostUp and ((close <= ema21 + 1.8*atr) or ta.crossunder(close, ema8) or (close < vwapSess) or (close < low[1]) or (close < close[1] and close[1] < close[2]))) ? 1 : 0
if allowLabels and _showPCT and withinPostUp and pct >= pxThresh
    label.new(bar_index, high, "PCT: " + str.tostring(pct), style=label.style_label_down, textcolor=color.white, color=color.new(color.orange, 0))

// ========== Position States ==========
var bool inShort = false
var int  barsShort = 0
var int  shortMOX  = 0

var bool inLong  = false
var int  barsLong = 0
var int  longMOX  = 0

// MOX helpers — scale min-hold by timeframe (unchanged)
getMinHoldShort() =>
    base = minHoldShortBase
    baseScaled = scaleEnabled ? math.round(base * tfMult) : base
    math.max(1, baseScaled)

getMinHoldLong() =>
    base = minHoldLongBase
    baseScaled = scaleEnabled ? math.round(base * tfMult) : base
    math.max(1, baseScaled)

// Enter states (now also gated by FlushMomentum)
if (barsSinceDown <= 2) and (fcsDn >= entryThresh) and fmGateShort
    inShort  := true
    barsShort:= 0
    shortMOX := getMinHoldShort()
    if allowLabels and _showMOX
        label.new(bar_index, high, "MOX↓ set: " + str.tostring(shortMOX), style=label.style_label_down, textcolor=color.white, color=color.new(color.red, 0))
    logIdx := logDo("SHORT", "ENTRY", close, fcsDn, NAf, NAf, logIdx)

if (barsSinceUp <= 2) and (fcsUp >= entryThresh) and fmGateLong
    inLong  := true
    barsLong:= 0
    longMOX := getMinHoldLong()
    if allowLabels and _showMOX
        label.new(bar_index, low, "MOX↑ set: " + str.tostring(longMOX), style=label.style_label_up, textcolor=color.white, color=color.new(color.green, 0))
    logIdx := logDo("LONG", "ENTRY", close, fcsUp, NAf, NAf, logIdx)

// ===== Reversal Strength & Trend Continuation
tcsDown = 0
tcsDown += ribbonBear and ribbonSlopeDn ? 1 : 0
tcsDown += close < vwapSess ? 1 : 0
tcsDown += ((ema21 - ema8) - nz((ema21 - ema8)[1]) + (ema34 - ema21) - nz((ema34 - ema21)[1]) > 0) ? 1 : 0
tcsDown += (moxieProxy < 0 and slope(moxieProxy,3) < 0) ? 1 : 0

rssUpFromDown = 0
rssUpFromDown += pcx >= pxEarlyThresh ? 1 : 0
rssUpFromDown += ta.crossover(close, ema8) ? 1 : 0
rssUpFromDown += close > high[1] ? 1 : 0
rssUpFromDown += (close > close[1] and close[1] > close[2]) ? 1 : 0
rssUpFromDown += (rsi > 50 and slope(rsi,3) > 0) ? 1 : 0
rssUpFromDown += close >= ema21 - 2*atr ? 1 : 0

tcsUp = 0
tcsUp += ribbonBull and ribbonSlopeUp ? 1 : 0
tcsUp += close > vwapSess ? 1 : 0
tcsUp += ((ema8 - ema21) - nz((ema8 - ema21)[1]) + (ema21 - ema34) - nz((ema21 - ema34)[1]) > 0) ? 1 : 0
tcsUp += (moxieProxy > 0 and slope(moxieProxy,3) > 0) ? 1 : 0

rssDnFromUp = 0
rssDnFromUp += pct >= pxEarlyThresh ? 1 : 0
rssDnFromUp += ta.crossunder(close, ema8) ? 1 : 0
rssDnFromUp += close < low[1] ? 1 : 0
rssDnFromUp += (close < close[1] and close[1] < close[2]) ? 1 : 0
rssDnFromUp += (rsi < 50 and slope(rsi,3) < 0) ? 1 : 0
rssDnFromUp += close <= ema21 + 2*atr ? 1 : 0

// MOX labels at expiry
if allowLabels and _showMOX and inShort and barsShort == shortMOX
    label.new(bar_index, low, "MOX↓", style=label.style_label_up, textcolor=color.white, color=color.new(color.yellow, 0))
if allowLabels and _showMOX and inLong and barsLong == longMOX
    label.new(bar_index, high, "MOX↑", style=label.style_label_down, textcolor=color.white, color=color.new(color.yellow, 0))

// ===== EARLY EXIT (unchanged logic)
tcsStrongDn   = tcsDown >= 3
moxieStillDn  = slope(moxieProxy, 3) < 0 and moxieProxy < 0
deepBelow2ATR = (ema21 - 2.0*atr) - close > 0.4*atr

bodySize   = math.abs(close - open)
prevBody   = math.abs(close[1] - open[1])
ftlSecondPoke = low <= low[2]
ftlWeaker     = (bodySize < prevBody) and ((high - low) > 0 ? (close - low) / (high - low) > pxWickMin : false)
ftlVolOK      = volume <= volume[1]
ftlValid      = ftlSecondPoke and ftlWeaker and ftlVolOK

higherLow        = low > low[1]
twoClosesAbove8  = close > ema8 and close[1] > ema8
volDecay         = ta.sma(volume, 3) < ta.sma(volume, 20)

requiredRSSShort = revThresh + (tcsStrongDn ? 2 : 1)
minFracShort     = tcsStrongDn ? 0.70 : 0.50
allowEarlyShort  = inShort and barsShort >= math.floor(shortMOX * minFracShort)

earlyExitOkShort =
     allowEarlyShort
  and rssUpFromDown >= requiredRSSShort
  and ftlValid and higherLow and twoClosesAbove8 and volDecay

suppressEarlyShort = deepBelow2ATR and moxieStillDn and tcsStrongDn

if allowLabels and _showEARLY and inShort and earlyExitOkShort and not suppressEarlyShort
    label.new(bar_index, low, "EARLY EXIT↓", style=label.style_label_up, textcolor=color.white, color=color.new(color.teal, 0))
    logIdx := logDo("SHORT", "EARLY↓", close, fcsDn, NAf, tcsDown+rssUpFromDown, logIdx)
    if closeOnEarly
        inShort   := false
        barsShort := 0

tcsStrongUp   = tcsUp >= 3
moxieStillUp  = slope(moxieProxy, 3) > 0 and moxieProxy > 0
deepAbove2ATR = close - (ema21 + 2.0*atr) > 0.4*atr

bodySizeU     = math.abs(close - open)
prevBodyU     = math.abs(close[1] - open[1])
fthSecondPoke = high >= high[2]
fthWeaker     = (bodySizeU < prevBodyU) and ((high - close) / math.max(high - low, 1e-6) > pxWickMin)
fthVolOK      = volume <= volume[1]
fthValid      = fthSecondPoke and fthWeaker and fthVolOK

lowerHigh        = high < high[1]
twoClosesBelow8  = close < ema8 and close[1] < ema8
volDecayU        = ta.sma(volume, 3) < ta.sma(volume, 20)

requiredRSSLong = revThresh + (tcsStrongUp ? 2 : 1)
minFracLong     = tcsStrongUp ? 0.70 : 0.50
allowEarlyLong  = inLong and barsLong >= math.floor(longMOX * minFracLong)

earlyExitOkLong =
     allowEarlyLong
  and rssDnFromUp >= requiredRSSLong
  and fthValid and lowerHigh and twoClosesBelow8 and volDecayU

suppressEarlyLong = deepAbove2ATR and moxieStillUp and tcsStrongUp

if allowLabels and _showEARLY and inLong and earlyExitOkLong and not suppressEarlyLong
    label.new(bar_index, high, "EARLY EXIT↑", style=label.style_label_down, textcolor=color.white, color=color.new(color.teal, 0))
    logIdx := logDo("LONG", "EARLY↑", close, fcsUp, NAf, tcsUp+rssDnFromUp, logIdx)
    if closeOnEarly
        inLong   := false
        barsLong := 0

// ===== Final EXIT (unchanged thresholds)
exitShortAllowed = inShort and (barsShort >= shortMOX or tcsDown <= 1)
exitShortCond =
      (close > ema8) or (close > vwapSess) or bullDiv
   or ((low < bandN3dn) and ((close >= ema21 - 1.8*atr) or (close > high[1])))
   or (close > math.max(high[1], high[2])) or (fcsDn <= exitThresh) or (barsShort > holdBarsMax)
if allowLabels and _showEXIT and exitShortAllowed and exitShortCond
    label.new(bar_index, low, "EXIT↓", style=label.style_label_up, textcolor=color.white, color=color.new(color.lime, 0))
    logIdx := logDo("SHORT", "EXIT↓", close, fcsDn, NAf, tcsDown, logIdx)
    inShort   := false
    barsShort := 0

exitLongAllowed = inLong and (barsLong >= longMOX or tcsUp <= 1)
exitLongCond =
      (close < ema8) or (close < vwapSess) or bearDiv
   or ((high > bandP3up) and ((close <= ema21 + 1.8*atr) or (close < low[1])))
   or (close < math.min(low[1], low[2])) or (fcsUp <= exitThresh) or (barsLong > holdBarsMax)
if allowLabels and _showEXIT and exitLongAllowed and exitLongCond
    label.new(bar_index, high, "EXIT↑", style=label.style_label_down, textcolor=color.white, color=color.new(color.lime, 0))
    logIdx := logDo("LONG", "EXIT↑", close, fcsUp, NAf, tcsUp, logIdx)
    inLong   := false
    barsLong := 0

// ===== Timers
if inShort
    barsShort += 1
if inLong
    barsLong  += 1

// ===== Simple on-chart logger (table) — ring buffer (no shifting)
if logEnabled and na(t)
    t := table.new(position.top_right, 7, logRows + 1)
    table.cell(t, 0, 0, "Bar",   text_color=color.white, bgcolor=color.new(color.silver, 25))
    table.cell(t, 1, 0, "Side",  text_color=color.white, bgcolor=color.new(color.silver, 25))
    table.cell(t, 2, 0, "Event", text_color=color.white, bgcolor=color.new(color.silver, 25))
    table.cell(t, 3, 0, "Price", text_color=color.white, bgcolor=color.new(color.silver, 25))
    table.cell(t, 4, 0, "FCS",   text_color=color.white, bgcolor=color.new(color.silver, 25))
    table.cell(t, 5, 0, "PCX/PCT",text_color=color.white, bgcolor=color.new(color.silver, 25))
    table.cell(t, 6, 0, "TCS/RSS",text_color=color.white, bgcolor=color.new(color.silver, 25))

// ===== Thin historical markers (cheap, full-history context)
plotshape(showHistoryShapes and (moxieCrossDown and fcsDn >= entryThresh),  title="FCS↓ mark",
          style=shape.triangledown, location=location.abovebar, size=size.tiny, color=color.new(color.red, 0))
plotshape(showHistoryShapes and (moxieCrossUp   and fcsUp >= entryThresh),  title="FCS↑ mark",
          style=shape.triangleup,   location=location.belowbar, size=size.tiny, color=color.new(color.green, 0))

plotshape(showHistoryShapes and (withinPostDn and pcx >= pxThresh), title="PCX mark",
          style=shape.circle, location=location.belowbar, size=size.tiny, color=color.new(color.lime, 0))
plotshape(showHistoryShapes and (withinPostUp and pct >= pxThresh), title="PCT mark",
          style=shape.circle, location=location.abovebar, size=size.tiny, color=color.new(color.orange, 0))

// ===== FlushMomentum debug: plots & FM gate dots =====
plot(showFMPlots ? oscFM      : na, title="FlushMomentum osc",    color=color.new(color.orange, 0), linewidth=2)
plot(showFMPlots ? moxieProxy : na, title="Moxie proxy (EMA close−34)", color=color.new(color.aqua, 0), linewidth=1)

plotshape(showFMDots and fmGateShort, title="FM Gate Short", style=shape.circle,
          location=location.abovebar, size=size.tiny, color=color.new(color.red, 0))
plotshape(showFMDots and fmGateLong,  title="FM Gate Long",  style=shape.circle,
          location=location.belowbar, size=size.tiny, color=color.new(color.lime, 0))
