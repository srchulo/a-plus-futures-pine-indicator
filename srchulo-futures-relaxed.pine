//@version=5
indicator("srchulo futures relaxed", overlay=true, max_labels_count=500)

// ===== Theming (distinct from strict)
cLong = color.rgb(102, 204, 255)
cShort = color.rgb(255, 160, 0)
cSetupLong = color.new(cLong, 60)
cSetupShort = color.new(cShort, 60)

// ---------- Profile / Sessions (NEW)
grpProfile = "Profile / Sessions"
profile = input.string("RTH", "Profile", options=["RTH","ETH (Globex)","ETH (Europe)"], group=grpProfile)
sessionStr_RTH = input.session("0935-1600", "RTH windows (exchange time)", group=grpProfile)
ethTradeStr_Globex = "1805-0925"
ethTradeStr_Europe = "0200-0925"

// Anchor windows (where AVWAP resets)
anchorStr = profile == "RTH" ? "0930-1600"
          : profile == "ETH (Europe)" ? "0200-1300"
          : "1700-1600"   // ETH (Globex) in Chicago time

// Trade windows (where signals are allowed)
sessionTradeStr = profile == "RTH" ? sessionStr_RTH : profile == "ETH (Europe)" ? ethTradeStr_Europe : ethTradeStr_Globex

// --- Timezone (force session/anchor interpretation in chosen zone)
tzRTH    = "America/New_York"
tzCME    = "America/Chicago"
tzEurope = "Europe/London"
tzProfile = profile == "RTH" ? tzRTH : profile == "ETH (Europe)" ? tzEurope : tzCME

// --- A+ time cutoff (ET) ---
aplusDisableET = input.session("1400-1600", "A+ disable window (ET)", group=grpProfile)
// True when we're inside the cutoff window (i.e., after 2pm ET)
aPlusBlocked = not na(time(timeframe.period, aplusDisableET, tzRTH))
aPlusAllowed = not aPlusBlocked

// ---------- Inputs
grpTrend = "Trend / Filters"
emaFastLen = input.int(8, "EMA Fast", group=grpTrend, minval=1)
emaMidLen = input.int(21, "EMA Mid", group=grpTrend, minval=1)
emaSlowLen = input.int(34, "EMA Slow", group=grpTrend, minval=1)
useRibbon = input.bool(true, "Require EMA ribbon alignment (LTF)", group=grpTrend)
htfTF = input.string("15", "HTF EMA ribbon (minutes)", group=grpTrend)
freezeHTF = input.bool(false, "Freeze HTF values (no intrabar updates)", group=grpTrend)
calcOnClose = input.bool(false, "Lock signals on bar close (no flicker)", group=grpTrend)

// === Internal "Moxie-like" slope settings (MTF-aware)
grpSlope = "Moxie-like Slope Filter"
slopeMode = input.string("MTF (All selected must agree)", "Slope Mode", options=["Current TF only","MTF (All selected must agree)"], group=grpSlope)
useTF_2m = input.bool(true, "Use 2m", group=grpSlope)
useTF_3m = input.bool(false, "Use 3m", group=grpSlope)
useTF_5m = input.bool(true, "Use 5m", group=grpSlope)
useTF_15m = input.bool(false, "Use 15m", group=grpSlope)
useTF_30m = input.bool(false, "Use 30m", group=grpSlope)
useTF_1h = input.bool(false, "Use 1h", group=grpSlope)
useTF_4h = input.bool(false, "Use 4h", group=grpSlope)
useTF_1D = input.bool(false, "Use 1D", group=grpSlope)
slopeLen = input.int(5, "Slope window (bars)", group=grpSlope, minval=2)
slopeSmooth = input.int(3, "Slope smoothing (EMA)", group=grpSlope, minval=1)
slopeMagLTF = input.float(0.00018, "Min slope magnitude (LTF)", group=grpSlope, step=0.00001)
slopeMagHTF = input.float(0.00013, "Min slope magnitude (MTF)", group=grpSlope, step=0.00001)
persistLTF = input.int(1, "Persistence LTF (bars ≥)", group=grpSlope, minval=0, maxval=5)
persistMTF = input.int(2, "Persistence MTF (bars ≥)", group=grpSlope, minval=0, maxval=5)
freezeSlopeMTF = input.bool(false, "Freeze MTF at closed bar (no intrabar flicker)", group=grpSlope)

grpVWAP = "VWAP / AVWAP"
useVWAP = input.bool(true, "Use session VWAP", group=grpVWAP)
useAVWAP = input.bool(true, "Use Anchored VWAP (profile open)", group=grpVWAP)
anchorTime = input.time(timestamp("01 Jan 2025 09:30 -0500"), "Anchored start (unused; uses profile)", group=grpVWAP)
pullDist = input.float(0.10, "Near VWAP distance (% ATR)", group=grpVWAP)
minVWAPBand = input.float(0.20, "Chop guard band (ATR*x)", group=grpVWAP)

grpVol = "Volume"
volLen = input.int(50, "Vol SMA", group=grpVol)
volMult = input.float(1.5, "Surge ≥ SMA *", group=grpVol)
requireVol = input.bool(true, "Require volume surge", group=grpVol)

grpDoji = "Candle Patterns"
dojiBodyPct = input.float(0.12, "Doji body ≤ x of range", group=grpDoji)
longWickK = input.float(2.0, "Long wick ≥ body *", group=grpDoji)
nearHiPct = input.float(0.25, "Body near high", group=grpDoji)
nearLoPct = input.float(0.25, "Body near low", group=grpDoji)

grpCont = "Continuation / Flag"
flagLookback = input.int(25, "Flag window", group=grpCont)
flagTightPct = input.float(0.45, "Flag tightness (≤ ATR * x)", group=grpCont)
breakBufATR = input.float(0.10, "Breakout buffer (ATR * x)", group=grpCont)

grpDec = "Decision Engine (weights + gating)"
useCompTrend = input.bool(true, "Use Trend in score", group=grpDec)
useCompNearVW = input.bool(true, "Use Near VWAP in score", group=grpDec)
useCompVolume = input.bool(true, "Use Volume in score", group=grpDec)
useCompPull = input.bool(true, "Use Pullback/Rally in score", group=grpDec)
useCompReclaim = input.bool(true, "Use VWAP Reclaim in score", group=grpDec)
useCompFlag = input.bool(true, "Use Flag in score", group=grpDec)
useCompPrec = input.bool(true, "Use Precision EMA in score", group=grpDec)
useCompCandle = input.bool(true, "Use Reversal Candle in score", group=grpDec)
useCompEngulf = input.bool(true, "Use Engulfing in score", group=grpDec)
useCompRetest = input.bool(true, "Use VWAP Retest/Flip in score", group=grpDec)
useCompBase = input.bool(true, "Use High/Low Base in score", group=grpDec)
useCompTri = input.bool(false, "Use Asc/Desc Triangle in score", group=grpDec)
useAtrGate = input.bool(false, "Use ATR floor gate", group=grpDec)
useSessionFilter = input.bool(true, "Use Session filter", group=grpDec)
useHTFFilter = input.bool(true, "Use HTF ribbon filter", group=grpDec)
useSlopeFilter = input.bool(true, "Use EMA slope filter", group=grpDec)
useChopGuard = input.bool(true, "Use VWAP chop-guard", group=grpDec)
useDailyCapGate = input.bool(true, "Use Daily-cap gate", group=grpDec)
triggerMode = input.string("Breakout", "Trigger mode", options=["Score","Simple","Breakout"], group=grpDec)
use3rdATRBlock = input.bool(false, "Block entries at 3rd ATR", group=grpDec)
atrMult3_gate = input.float(3.0, "ATR x for 3rd-ATR block", group=grpDec, step=0.1)
oneAndDone = input.bool(false, "One-and-done (stop after first confirm)", group=grpDec)
minRangeATR = input.float(0.20, "Min bar range (ATR x)", group=grpDec, step=0.05)
nearTicks = input.int(3, "Heads-up proximity (ticks)", group=grpDec, minval=0)
useATR2MomFilter = input.bool(true, "Use >2nd-ATR momentum+vol filter (both sides)", group=grpDec)
volRelaxException = input.float(1.20, "Vol × when >2nd ATR (Relaxed)", group=grpDec, step=0.05)
wTrend = input.int(2, "W Trend", group=grpDec, minval=0, maxval=5)
wVWAPPb = input.int(1, "W Near VWAP", group=grpDec, minval=0, maxval=5)
wVolume = input.int(1, "W Volume", group=grpDec, minval=0, maxval=5)
wPull = input.int(2, "W Pull/Rally", group=grpDec, minval=0, maxval=5)
wReclaim = input.int(3, "W Reclaim", group=grpDec, minval=0, maxval=5)
wFlag = input.int(0, "W Flag", group=grpDec, minval=0, maxval=5)
wPrec = input.int(2, "W Precision", group=grpDec, minval=0, maxval=5)
wCandle = input.int(1, "W Candle", group=grpDec, minval=0, maxval=5)
wEngulf = input.int(2, "W Engulf", group=grpDec, minval=0, maxval=5)
wRetest = input.int(3, "W VWAP Retest", group=grpDec, minval=0, maxval=5)
wBase = input.int(2, "W Base", group=grpDec, minval=0, maxval=5)
wTri = input.int(1, "W Triangle", group=grpDec, minval=0, maxval=5)
threshLong = input.int(5, "Score threshold LONG", group=grpDec, minval=1)
threshShort = input.int(5, "Score threshold SHORT", group=grpDec, minval=1)
minAtrTicks = input.int(22, "Min ATR (ticks) gate", group=grpDec)
entryConfirmTicks = input.int(1, "Entry confirmation (ticks beyond signal bar)", group=grpDec)
cooldownBars = input.int(10, "Cooldown bars", group=grpDec)
maxSignalsPerDay = input.int(100, "Max signals per day", group=grpDec)
ticksTol = input.int(4, "Structure tolerance (ticks)", group=grpDec)
retestBars = input.int(5, "VWAP retest within N bars", group=grpDec)

// ---------- Show / Alerts
grpShow = "Show / Alerts"
showContext = input.bool(false, "Plot EMAs + VWAP/AVWAP", group=grpShow)
showSetups = input.bool(true, "Plot setup arrows", group=grpShow)
enableAlerts = input.bool(true, "Enable confirmed entry alerts", group=grpShow)
showCountdown = input.bool(true, "Show bar-close countdown", group=grpShow)

// ---------- Core series
atrLen = 14
atr = ta.atr(atrLen)
safeMintick = syminfo.mintick == 0.0 ? 0.25 : syminfo.mintick
atrTicks = math.round(atr / safeMintick)
emaF = ta.ema(close, emaFastLen)
emaM = ta.ema(close, emaMidLen)
emaS = ta.ema(close, emaSlowLen)
ribbonBull = emaF > emaM and emaM > emaS
ribbonBear = emaF < emaM and emaM < emaS
trendOkLong = useRibbon ? ribbonBull : true
trendOkShort = useRibbon ? ribbonBear : true

// <<< RESTORED simple EMA slopes used by relaxed ATR filters >>>
emaSlopeLong = emaM > emaM[5] and emaS > emaS[5]
emaSlopeShort = emaM < emaM[5] and emaS < emaS[5]

// -------------------- Session & VWAPs (UPDATED) --------------------
vwap = ta.vwap(close)
inTradeSess = not na(time(timeframe.period, sessionTradeStr, tzProfile))
inAnchor = not na(time(timeframe.period, anchorStr,      tzProfile))
sessionStart = inAnchor and not inAnchor[1]

// --- Anchor diagnostics (marker + daily OK flag)
var int _anchor_bar = na
var bool _newDayFlag = false
_newDayFlag := ta.change(time("D")) != 0
if _newDayFlag
    _anchor_bar := na
if sessionStart
    _anchor_bar := bar_index
plotshape(sessionStart, title="AVWAP Anchor", style=shape.triangledown, location=location.top, size=size.tiny, color=color.new(color.purple, 0), text="AVWAP")
barsSinceAnchor = ta.barssince(sessionStart)
barsSinceDay = ta.barssince(_newDayFlag)
anchorOK_today = (not na(barsSinceAnchor)) and (not na(barsSinceDay)) and (barsSinceAnchor <= barsSinceDay)

// Anchored VWAP (resets at profile anchor open) — persist outside trade session
var float avwap = na
var float aPV = 0.0
var float aV = 0.0
if barstate.isnew
    if sessionStart
        aPV := 0.0
        aV  := 0.0
        avwap := na
    if inTradeSess
        tp = (high + low + close) / 3.0
        aPV += tp * volume
        aV  += volume
        avwap := aV > 0 ? aPV / aV : na
// IMPORTANT: no reset when not inTradeSess — AVWAP line persists

plot((showContext and useVWAP) ? vwap : na, "VWAP", color=color.new(color.teal, 0), linewidth=2)
plot((showContext and useAVWAP) ? avwap : na, "Anchor VWAP (profile open)", color=color.new(color.purple, 0), linewidth=2)
plot(showContext ? emaF : na, "EMA Fast", color=color.new(color.white, 0))
plot(showContext ? emaM : na, "EMA Mid", color=color.new(color.orange, 0))
plot(showContext ? emaS : na, "EMA Slow", color=color.new(color.maroon, 0))

// HTF EMA ribbon
htfE1 = request.security(syminfo.tickerid, htfTF, ta.ema(close, emaFastLen), lookahead=freezeHTF ? barmerge.lookahead_on : barmerge.lookahead_off)
htfE2 = request.security(syminfo.tickerid, htfTF, ta.ema(close, emaMidLen), lookahead=freezeHTF ? barmerge.lookahead_on : barmerge.lookahead_off)
htfE3 = request.security(syminfo.tickerid, htfTF, ta.ema(close, emaSlowLen), lookahead=freezeHTF ? barmerge.lookahead_on : barmerge.lookahead_off)
htfBull = htfE1 > htfE2 and htfE2 > htfE3
htfBear = htfE1 < htfE2 and htfE2 < htfE3

// --- HTF heads-up (preview vs locked) ---
htfBull_preview = request.security(syminfo.tickerid, htfTF, ta.ema(close, emaFastLen) > ta.ema(close, emaMidLen) and ta.ema(close, emaMidLen) > ta.ema(close, emaSlowLen), lookahead=barmerge.lookahead_off)
htfBear_preview = request.security(syminfo.tickerid, htfTF, ta.ema(close, emaFastLen) < ta.ema(close, emaMidLen) and ta.ema(close, emaMidLen) < ta.ema(close, emaSlowLen), lookahead=barmerge.lookahead_off)
htfBull_locked = htfBull
htfBear_locked = htfBear
plotshape(htfBull_preview and not htfBull_locked, title="HTF Heads-Up (Long)", style=shape.circle, location=location.top, size=size.tiny, color=color.new(color.green, 0))
plotshape(htfBear_preview and not htfBear_locked, title="HTF Heads-Up (Short)", style=shape.circle, location=location.bottom, size=size.tiny, color=color.new(color.red, 0))

// Candles / volume
volSMA = ta.sma(volume, volLen)
volSurge = volume >= volSMA * volMult
volOK = requireVol ? volSurge : true
rng = math.max(high - low, safeMintick)
body = math.abs(close - open)
upper = high - math.max(open, close)
lower = math.min(open, close) - low
isDoji = body <= rng * dojiBodyPct
nearHighBody = (high - math.max(open, close)) <= rng * nearHiPct
nearLowBody = (math.min(open, close) - low) <= rng * nearLoPct
dragonfly = isDoji and lower >= body * longWickK and nearHighBody
gravestone = isDoji and upper >= body * longWickK and nearLowBody
hammer = (lower >= body * longWickK) and nearHighBody and not isDoji
shootingStar = (upper >= body * longWickK) and nearLowBody and not isDoji

// Engulf / inside
bullEngulf = close > open and open <= close[1] and close >= open[1] and close > close[1]
bearEngulf = close < open and open >= close[1] and close <= open[1] and close < close[1]
insideBar = high < high[1] and low > low[1]

// Proximity + chop guard
withinPctOfATR(src, pct) => na(src) ? false : math.abs(close - src) <= atr * pct
nearAnyVWAP_raw = (useVWAP and withinPctOfATR(vwap, pullDist)) or (useAVWAP and withinPctOfATR(avwap, pullDist))
cgRaw = (useVWAP and withinPctOfATR(vwap, minVWAPBand)) or (useAVWAP and withinPctOfATR(avwap, minVWAPBand))
inVWAPChop_close = ta.valuewhen(barstate.isconfirmed, cgRaw, 0)
inVWAPChop_raw = cgRaw
inVWAPChop = useChopGuard ? (calcOnClose ? inVWAPChop_close : inVWAPChop_raw) : false
nearAnyVWAP = nearAnyVWAP_raw

// ================== NEW SLOPE (MOXIE-LIKE) LOGIC ==================
f_internal_slope(_close, _fastLen, _midLen, _slowLen, _slopeLen, _smooth) =>
    _fast = ta.ema(_close, _fastLen), _mid = ta.ema(_close, _midLen), _slow = ta.ema(_close, _slowLen), _spread = (_fast - _mid) + (_mid - _slow), _raw = ta.linreg(_spread, _slopeLen, 0), _sm = _smooth > 1 ? ta.ema(_raw, _smooth) : _raw, nz(_sm) / math.max(math.abs(_mid), 1e-6)

f_slope_ok(tf, magMin, persistBars, _freeze) =>
    _lk = _freeze ? barmerge.lookahead_on : barmerge.lookahead_off
    _s = request.security(syminfo.tickerid, tf, f_internal_slope(close, emaFastLen, emaMidLen, emaSlowLen, slopeLen, slopeSmooth), lookahead=_lk)
    _up = _s > magMin, _down = _s < -magMin, _upOK = ta.barssince(_down) > persistBars, _downOK = ta.barssince(_up) > persistBars, [_up, _down, _upOK, _downOK]

f_slope_current() =>
    _s = f_internal_slope(close, emaFastLen, emaMidLen, emaSlowLen, slopeLen, slopeSmooth)
    _up = _s > slopeMagLTF, _down = _s < -slopeMagLTF, _upOK = ta.barssince(_down) > persistLTF, _downOK = ta.barssince(_up) > persistLTF, [_up, _down, _upOK, _downOK]

var string TF2 = "2", TF3 = "3", TF5 = "5", TF15 = "15", TF30 = "30", TF60 = "60", TF240 = "240", TFD = "D"
[ctf_up, ctf_dn, ctf_upok, ctf_dnok] = f_slope_current()
mtf_any_selected = false, mtf_all_up = true, mtf_all_dn = true
if slopeMode == "MTF (All selected must agree)"
    if useTF_2m
        mtf_any_selected := true
        [u2, d2, uok2, dok2] = f_slope_ok(TF2, slopeMagHTF, persistMTF, freezeSlopeMTF)
        mtf_all_up := mtf_all_up and (u2 and uok2)
        mtf_all_dn := mtf_all_dn and (d2 and dok2)
    if useTF_3m
        mtf_any_selected := true
        [u3, d3, uok3, dok3] = f_slope_ok(TF3, slopeMagHTF, persistMTF, freezeSlopeMTF)
        mtf_all_up := mtf_all_up and (u3 and uok3)
        mtf_all_dn := mtf_all_dn and (d3 and dok3)
    if useTF_5m
        mtf_any_selected := true
        [u5, d5, uok5, dok5] = f_slope_ok(TF5, slopeMagHTF, persistMTF, freezeSlopeMTF)
        mtf_all_up := mtf_all_up and (u5 and uok5)
        mtf_all_dn := mtf_all_dn and (d5 and dok5)
    if useTF_15m
        mtf_any_selected := true
        [u15, d15, uok15, dok15] = f_slope_ok(TF15, slopeMagHTF, persistMTF, freezeSlopeMTF)
        mtf_all_up := mtf_all_up and (u15 and uok15)
        mtf_all_dn := mtf_all_dn and (d15 and dok15)
    if useTF_30m
        mtf_any_selected := true
        [u30, d30, uok30, dok30] = f_slope_ok(TF30, slopeMagHTF, persistMTF, freezeSlopeMTF)
        mtf_all_up := mtf_all_up and (u30 and uok30)
        mtf_all_dn := mtf_all_dn and (d30 and dok30)
    if useTF_1h
        mtf_any_selected := true
        [u60, d60, uok60, dok60] = f_slope_ok(TF60, slopeMagHTF, persistMTF, freezeSlopeMTF)
        mtf_all_up := mtf_all_up and (u60 and uok60)
        mtf_all_dn := mtf_all_dn and (d60 and dok60)
    if useTF_4h
        mtf_any_selected := true
        [u240, d240, uok240, dok240] = f_slope_ok(TF240, slopeMagHTF, persistMTF, freezeSlopeMTF)
        mtf_all_up := mtf_all_up and (u240 and uok240)
        mtf_all_dn := mtf_all_dn and (d240 and dok240)
    if useTF_1D
        mtf_any_selected := true
        [ud, dd, uokd, dokd] = f_slope_ok(TFD, slopeMagHTF, persistMTF, freezeSlopeMTF)
        mtf_all_up := mtf_all_up and (ud and uokd)
        mtf_all_dn := mtf_all_dn and (dd and dokd)

useCurrentFallback = (slopeMode == "MTF (All selected must agree)") and (not mtf_any_selected)
slopeLongOK_new = slopeMode == "Current TF only" ? (ctf_up and ctf_upok) : useCurrentFallback ? (ctf_up and ctf_upok) : mtf_all_up
slopeShortOK_new = slopeMode == "Current TF only" ? (ctf_dn and ctf_dnok) : useCurrentFallback ? (ctf_dn and ctf_dnok) : mtf_all_dn

// Setups
bullReversalCandle = hammer or dragonfly or (close > open and close > open[1] and low <= low[1])
pullbackLong = trendOkLong and nearAnyVWAP and bullReversalCandle and close > ta.highest(high[1], 1)
bearReversalCandle = shootingStar or gravestone or (close < open and close < open[1] and high >= high[1])
rallyShort = trendOkShort and nearAnyVWAP and bearReversalCandle and close < ta.lowest(low[1], 1)
wasBelowVWAP = useVWAP and close[1] < vwap[1]
nowAboveVWAP = useVWAP and close > vwap
wasAboveVWAP = useVWAP and close[1] > vwap[1]
nowBelowVWAP = useVWAP and close < vwap
vwapReclaimLong = trendOkLong and (wasBelowVWAP and nowAboveVWAP) and volOK
vwapReclaimShort = trendOkShort and (wasAboveVWAP and nowBelowVWAP) and volOK
tolP = atr * 0.10
bullRetest = ta.barssince(wasBelowVWAP and nowAboveVWAP) <= retestBars and math.abs(low - vwap) <= tolP and close > vwap
bearRetest = ta.barssince(wasAboveVWAP and nowBelowVWAP) <= retestBars and math.abs(high - vwap) <= tolP and close < vwap
rangeHi = ta.highest(high, flagLookback)
rangeLo = ta.lowest(low, flagLookback)
rangeTight = (rangeHi - rangeLo) <= atr * flagTightPct
bullFlag  = trendOkLong and rangeTight and close > rangeHi[1] + atr * breakBufATR
bearFlag  = trendOkShort and rangeTight and close < rangeLo[1] - atr * breakBufATR
tolPx  = ticksTol * safeMintick
flatHi = math.abs(rangeHi - rangeHi[1]) <= tolPx
flatLo = math.abs(rangeLo - rangeLo[1]) <= tolPx
riseL  = ta.lowest(low, flagLookback)  > ta.lowest(low, flagLookback)[1]
fallH  = ta.highest(high,flagLookback) < ta.highest(high,flagLookback)[1]
highBase = trendOkLong and rangeTight and flatHi and riseL
lowBase  = trendOkShort and rangeTight and flatLo and fallH
ascTri   = trendOkLong and flatHi and riseL
descTri  = trendOkShort and flatLo and fallH
precisionLong  = trendOkLong and (math.abs(close - emaM) <= atr * 0.15 or math.abs(close - emaS) <= atr * 0.15) and bullReversalCandle
precisionShort = trendOkShort and (math.abs(close - emaM) <= atr * 0.15 or math.abs(close - emaS) <= atr * 0.15) and bearReversalCandle

// Scoring
scoreAdd(c, w, use) => use and c ? w : 0
reclaimLongPrim = wasBelowVWAP and nowAboveVWAP
reclaimShortPrim = wasAboveVWAP and nowBelowVWAP
bullCandle = hammer or dragonfly
bearCandle = shootingStar or gravestone
longScore = scoreAdd(trendOkLong, wTrend, useCompTrend) + scoreAdd(not inVWAPChop and nearAnyVWAP, wVWAPPb, useCompNearVW) + scoreAdd(volOK, wVolume, useCompVolume) + scoreAdd(pullbackLong, wPull, useCompPull) + scoreAdd(reclaimLongPrim, wReclaim, useCompReclaim) + scoreAdd(bullFlag, wFlag, useCompFlag) + scoreAdd(precisionLong, wPrec, useCompPrec) + scoreAdd(bullCandle, wCandle, useCompCandle) + scoreAdd(bullEngulf, wEngulf, useCompEngulf) + scoreAdd(bullRetest, wRetest, useCompRetest) + scoreAdd(highBase, wBase, useCompBase) + scoreAdd(ascTri, wTri, useCompTri)
shortScore = scoreAdd(trendOkShort, wTrend, useCompTrend) + scoreAdd(not inVWAPChop and nearAnyVWAP, wVWAPPb, useCompNearVW) + scoreAdd(volOK, wVolume, useCompVolume) + scoreAdd(rallyShort, wPull, useCompPull) + scoreAdd(reclaimShortPrim, wReclaim, useCompReclaim) + scoreAdd(bearFlag, wFlag, useCompFlag) + scoreAdd(precisionShort, wPrec, useCompPrec) + scoreAdd(bearCandle, wCandle, useCompCandle) + scoreAdd(bearEngulf, wEngulf, useCompEngulf) + scoreAdd(bearRetest, wRetest, useCompRetest) + scoreAdd(lowBase, wBase, useCompBase) + scoreAdd(descTri, wTri, useCompTri)

// Gating toggles (use profile session consistently)
gateSessOK = useSessionFilter ? inTradeSess : true
gateAtrOK = useAtrGate ? atrTicks >= minAtrTicks : true
gateHTFLong = useHTFFilter ? htfBull : true
gateHTFShort = useHTFFilter ? htfBear : true
gateSlopeL = useSlopeFilter ? slopeLongOK_new : true
gateSlopeS = useSlopeFilter ? slopeShortOK_new : true

// Cooldown + daily cap + one-and-done
var int lastSignalBar = na
newDay = ta.change(time("D")) != 0
var int signalsToday = 0
var bool tookEntryToday = false
if newDay
    signalsToday := 0, lastSignalBar := na, tookEntryToday := false
readyForNew = na(lastSignalBar) or (bar_index - lastSignalBar > cooldownBars)
capRaw = signalsToday < maxSignalsPerDay
gateDailyOK = useDailyCapGate ? capRaw : true

// SIMPLE triggers (bypass score if chosen)
simpleLong = trendOkLong and (precisionLong or vwapReclaimLong or bullRetest or bullEngulf or pullbackLong or bullFlag or highBase or ascTri) and (not useChopGuard or not inVWAPChop)
simpleShort = trendOkShort and (precisionShort or vwapReclaimShort or bearRetest or bearEngulf or rallyShort or bearFlag or lowBase or descTri) and (not useChopGuard or not inVWAPChop)

// 3rd-ATR block + range quality + one-and-done
ema34 = ta.ema(close, 34)
up3_gate = ema34 + atr * atrMult3_gate
dn3_gate = ema34 - atr * atrMult3_gate
atOrBeyond3rd = close >= up3_gate or close <= dn3_gate
rangeOK = (high - low) >= atr * minRangeATR

// >2nd-ATR helpers (symmetrical, relaxed)
up2_gate = ema34 + atr * 2.0
dn2_gate = ema34 - atr * 2.0
momRise2 = close > close[1] and close[1] > close[2]
momFall2 = close < close[1] and close[1] < close[2]
relaxedATRMomOK_L = (not atOrBeyond3rd) and ((close <= up2_gate and (emaSlopeLong or htfBull_locked)) or (close > up2_gate and (emaSlopeLong or htfBull_locked) and momRise2 and (volume >= volSMA * volRelaxException)))
relaxedATRMomOK_S = (not atOrBeyond3rd) and ((close >= dn2_gate and (emaSlopeShort or htfBear_locked)) or (close < dn2_gate and (emaSlopeShort or htfBear_locked) and momFall2 and (volume >= volSMA * volRelaxException)))

// Final setups
useScore = triggerMode == "Score"
useSimple = triggerMode == "Simple"
useBreak = triggerMode == "Breakout"
baseLongGates_core = readyForNew and gateDailyOK and gateSessOK and gateAtrOK and gateHTFLong and gateSlopeL and trendOkLong and (not useChopGuard or not inVWAPChop)
baseShortGates_core = readyForNew and gateDailyOK and gateSessOK and gateAtrOK and gateHTFShort and gateSlopeS and trendOkShort and (not useChopGuard or not inVWAPChop)
baseLongGates = baseLongGates_core and (not use3rdATRBlock or not atOrBeyond3rd) and (not oneAndDone or not tookEntryToday) and (not useATR2MomFilter or relaxedATRMomOK_L)
baseShortGates = baseShortGates_core and (not use3rdATRBlock or not atOrBeyond3rd) and (not oneAndDone or not tookEntryToday) and (not useATR2MomFilter or relaxedATRMomOK_S)
baseLongSetup = (useScore ? (longScore >= threshLong) : useSimple ? simpleLong : true) and baseLongGates
baseShortSetup = (useScore ? (shortScore >= threshShort) : useSimple ? simpleShort : true) and baseShortGates

// Confirmation + finalize
longStopPrice = high + entryConfirmTicks * safeMintick
shortStopPrice = low - entryConfirmTicks * safeMintick
breakoutLongNow = (high - low) >= atr * 0.20 and high >= high[1] + entryConfirmTicks * safeMintick
breakoutShortNow = (high - low) >= atr * 0.20 and low <= low[1] - entryConfirmTicks * safeMintick
longConfirm_raw = (useBreak ? (baseLongSetup and breakoutLongNow) : (baseLongSetup[1] and high >= longStopPrice[1])) and rangeOK
shortConfirm_raw = (useBreak ? (baseShortSetup and breakoutShortNow) : (baseShortSetup[1] and low <= shortStopPrice[1])) and rangeOK
finalize(b) => calcOnClose ? (barstate.isconfirmed ? b : false) : b
longConfirm = finalize(longConfirm_raw)
shortConfirm = finalize(shortConfirm_raw)

// --- Hard-block A+ confirms after cutoff ---
longConfirm := longConfirm and aPlusAllowed
shortConfirm := shortConfirm and aPlusAllowed

// Near-trigger heads-up
pxBuf = nearTicks * safeMintick
nearTriggerLong = (useBreak ? (baseLongSetup and high >= (high[1] + entryConfirmTicks * safeMintick) - pxBuf) : (baseLongSetup[1] and high >= ((high[1] + entryConfirmTicks * safeMintick) - pxBuf)))
nearTriggerShort = (useBreak ? (baseShortSetup and low <= (low[1] - entryConfirmTicks * safeMintick) + pxBuf) : (baseShortSetup[1] and low <= ((low[1] - entryConfirmTicks * safeMintick) + pxBuf)))
softHeadsUpLong = (not useSessionFilter or inTradeSess) and nearTriggerLong and htfBull_preview and not htfBull_locked
softHeadsUpShort = (not useSessionFilter or inTradeSess) and nearTriggerShort and htfBear_preview and not htfBear_locked
alertcondition(softHeadsUpLong, title="Heads-Up LONG", message="Heads-up: close could confirm LONG")
alertcondition(softHeadsUpShort, title="Heads-Up SHORT", message="Heads-up: close could confirm SHORT")

// Gate Debug panel
grpDbg = "Debug"
showGateDebug = input.bool(false, "Show Gate Debug panel", group=grpDbg)
gateColor(b) => b ? color.new(color.lime, 0) : color.new(color.red, 0)
textYesNo(b) => b ? "YES" : "NO"
var table dbg = na
if barstate.isfirst
    dbg := table.new(position.top_right, 4, 16, border_width=1)
if showGateDebug and barstate.islast
    modeTxt = useScore ? "Score" : useSimple ? "Simple" : "Breakout"
    table.cell(dbg, 0, 0, "Gate", text_color=color.black, bgcolor=color.new(color.yellow, 0))
    table.cell(dbg, 1, 0, "LONG", text_color=color.black, bgcolor=color.new(color.yellow, 0))
    table.cell(dbg, 2, 0, "SHORT", text_color=color.black, bgcolor=color.new(color.yellow, 0))
    table.cell(dbg, 3, 0, "Mode: " + modeTxt, text_color=color.black, bgcolor=color.new(color.orange, 20))
    table.cell(dbg, 0, 1, "Score >= Thresh")
    table.cell(dbg, 1, 1, textYesNo(longScore >= threshLong), bgcolor=gateColor(longScore >= threshLong))
    table.cell(dbg, 2, 1, textYesNo(shortScore >= threshShort), bgcolor=gateColor(shortScore >= threshShort))
    table.cell(dbg, 0, 2, "Cooldown OK")
    table.cell(dbg, 1, 2, textYesNo(readyForNew), bgcolor=gateColor(readyForNew))
    table.cell(dbg, 2, 2, textYesNo(readyForNew), bgcolor=gateColor(readyForNew))
    table.cell(dbg, 0, 3, "Daily Cap OK")
    table.cell(dbg, 1, 3, textYesNo(gateDailyOK), bgcolor=gateColor(gateDailyOK))
    table.cell(dbg, 2, 3, textYesNo(gateDailyOK), bgcolor=gateColor(gateDailyOK))
    table.cell(dbg, 0, 4, "Session OK")
    table.cell(dbg, 1, 4, textYesNo(gateSessOK), bgcolor=gateColor(gateSessOK))
    table.cell(dbg, 2, 4, textYesNo(gateSessOK), bgcolor=gateColor(gateSessOK))
    table.cell(dbg, 0, 5, "ATR OK")
    table.cell(dbg, 1, 5, textYesNo(gateAtrOK), bgcolor=gateColor(gateAtrOK))
    table.cell(dbg, 2, 5, textYesNo(gateAtrOK), bgcolor=gateColor(gateAtrOK))
    table.cell(dbg, 0, 6, "HTF OK")
    table.cell(dbg, 1, 6, textYesNo(gateHTFLong), bgcolor=gateColor(gateHTFLong))
    table.cell(dbg, 2, 6, textYesNo(gateHTFShort), bgcolor=gateColor(gateHTFShort))
    table.cell(dbg, 0, 7, "Slope OK")
    table.cell(dbg, 1, 7, textYesNo(gateSlopeL), bgcolor=gateColor(gateSlopeL))
    table.cell(dbg, 2, 7, textYesNo(gateSlopeS), bgcolor=gateColor(gateSlopeS))
    table.cell(dbg, 0, 10, "Anchor OK")
    table.cell(dbg, 1, 10, textYesNo(anchorOK_today), bgcolor=gateColor(anchorOK_today))
    table.cell(dbg, 2, 10, textYesNo(anchorOK_today), bgcolor=gateColor(anchorOK_today))

// latch cooldown & one-and-done
if barstate.isconfirmed and (longConfirm or shortConfirm)
    lastSignalBar := bar_index, signalsToday += 1, tookEntryToday := true

// ==================== EXIT / MANAGEMENT ====================
grpExit = "Exit / Management (Continuation Aware)"
usePartialATR = input.bool(true, "Take partial at 3×ATR from entry", group=grpExit)
partialATRs = input.float(3.0, "Partial ATR multiple", group=grpExit, step=0.1)
trailATRs = input.float(1.5, "ATR trail (from HH/LL since entry)", group=grpExit, step=0.1)
exitOnMomHook = input.bool(true, "Exit-soon on momentum hook (MACD hist turns up/down)", group=grpExit)
exitOnPriorHL = input.bool(true, "Hard exit on prior bar H/L break", group=grpExit)
exitOnVWAPFlip = input.bool(true, "Hard exit on VWAP/AVWAP reclaim", group=grpExit)
exitOnEMASpread = input.bool(true, "Exit-soon on EMA spread narrowing", group=grpExit)
emaSpreadLook = input.int(3, "EMA spread lookback (bars)", group=grpExit, minval=1)
showTrails = input.bool(true, "Plot dynamic ATR trails", group=grpExit)
enableExitAlerts = input.bool(true, "Enable exit/partial alerts", group=grpExit)
exitHookBars = input.int(2, "MACD hook pivot bars", group=grpExit, minval=1, maxval=5)
spreadShrinkPct = input.float(0.03, "EMA spread shrink ≥", group=grpExit, step=0.005)
needStruct = input.bool(true, "Require LH/HL with hook", group=grpExit)
needVolFade = input.bool(false, "Require volume < SMA on exit-soon", group=grpExit)
showExitSoonFlags = input.bool(true, "Show 'Exit Soon' flags", group=grpExit)
showHardExitFlags = input.bool(true, "Show 'Hard Exit' crosses", group=grpExit)
exitSoonColor = input.color(color.rgb(167, 139, 250), "Exit Soon color", group=grpExit)
hardExitColor = input.color(color.rgb(255, 77, 136), "Hard Exit color", group=grpExit)

[macdLine, macdSignal, macdHist] = ta.macd(close, 12, 26, 9)
spreadNow = math.abs(emaM - emaF)
spreadPrev = math.abs(emaM[emaSpreadLook] - emaF[emaSpreadLook])
var bool inLong = false, inShort = false
var float entryPrice = na
var int entrySide = 0
longEnter = barstate.isconfirmed and longConfirm
shortEnter = barstate.isconfirmed and shortConfirm
if longEnter
    inLong := true, inShort := false, entryPrice := close, entrySide := 1
if shortEnter
    inShort := true, inLong := false, entryPrice := close, entrySide := -1

var float runLL = na
var float runHH = na
runLL := inLong ? ((na(runLL[1]) or longEnter) ? low : math.min(runLL[1], low)) : na
runHH := inShort ? ((na(runHH[1]) or shortEnter) ? high : math.max(runHH[1], high)) : na
trailLong = nz(runLL) - atr * trailATRs
trailShort = nz(runHH) + atr * trailATRs
partialLong = inLong and usePartialATR and close >= entryPrice + atr * partialATRs
partialShort = inShort and usePartialATR and close <= entryPrice - atr * partialATRs

macdHookDn = ta.change(macdHist) < 0 and ta.change(macdHist, exitHookBars) >= 0
macdHookUp = ta.change(macdHist) > 0 and ta.change(macdHist, exitHookBars) <= 0
spreadNarrow = spreadNow <= spreadPrev * (1 - spreadShrinkPct)
lowerHigh = high <= high[1]
higherLow = low >= low[1]
volFade = volume < volSMA
momHookLong = inLong and exitOnMomHook and macdHookDn
momHookShort = inShort and exitOnMomHook and macdHookUp
emaNarrowLong = inLong and exitOnEMASpread and spreadNarrow
emaNarrowShort = inShort and exitOnEMASpread and spreadNarrow
hardExitLong = inLong and ((close <= trailLong) or (exitOnVWAPFlip and ((useVWAP and close < vwap) or (useAVWAP and (not na(avwap) and close < avwap)))) or (exitOnPriorHL and close < low[1]))
hardExitShort = inShort and ((close >= trailShort) or (exitOnVWAPFlip and ((useVWAP and close > vwap) or (useAVWAP and (not na(avwap) and close > avwap)))) or (exitOnPriorHL and close > high[1]))
exitSoonLong = inLong and ((momHookLong or emaNarrowLong)) and (not needStruct or lowerHigh) and (not needVolFade or volFade)
exitSoonShort = inShort and ((momHookShort or emaNarrowShort)) and (not needStruct or higherLow) and (not needVolFade or volFade)
if barstate.isconfirmed and hardExitLong
    inLong := false, entrySide := 0
if barstate.isconfirmed and hardExitShort
    inShort := false, entrySide := 0

// ---------- Trails & Exit markers
plot(showTrails and inLong ? trailLong : na, "Long ATR Trail", color=cLong, linewidth=1, style=plot.style_linebr)
plot(showTrails and inShort ? trailShort : na, "Short ATR Trail", color=cShort, linewidth=1, style=plot.style_linebr)
plotshape(partialLong,  title="Partial LONG 3xATR",  style=shape.circle, location=location.abovebar, color=cLong,  size=size.tiny, text="PARTIAL")
plotshape(partialShort, title="Partial SHORT 3xATR", style=shape.circle, location=location.belowbar, color=cShort, size=size.tiny, text="PARTIAL")
plotshape(showExitSoonFlags and exitSoonLong,  title="Exit Soon LONG",  style=shape.flag,  location=location.abovebar, color=color.rgb(167,139,250), size=size.tiny, text="EXIT SOON")
plotshape(showExitSoonFlags and exitSoonShort, title="Exit Soon SHORT", style=shape.flag,  location=location.belowbar, color=color.rgb(167,139,250), size=size.tiny, text="EXIT SOON")
plotshape(showHardExitFlags and hardExitLong,  title="HARD EXIT LONG",  style=shape.cross, location=location.abovebar, color=color.new(color.red, 0), size=size.tiny, text="EXIT")
plotshape(showHardExitFlags and hardExitShort, title="HARD EXIT SHORT", style=shape.cross, location=location.belowbar, color=color.new(color.red, 0), size=size.tiny, text="EXIT")

// Plot arrows (finalized only)
plotshape(showSetups and baseLongSetup,  title="Setup LONG",  style=shape.triangleup,   location=location.belowbar, color=cSetupLong,  size=size.tiny, text="setup")
plotshape(showSetups and baseShortSetup, title="Setup SHORT", style=shape.triangledown, location=location.abovebar, color=cSetupShort, size=size.tiny, text="setup")
plotshape(longConfirm,  title="A+ LONG (confirmed)",  style=shape.triangleup,   location=location.belowbar, color=cLong,  size=size.large, text="A+ LONG")
plotshape(shortConfirm, title="A+ SHORT (confirmed)", style=shape.triangledown, location=location.abovebar, color=cShort, size=size.large, text="A+ SHORT")
bgcolor(longConfirm ? color.new(cLong, 85) : shortConfirm ? color.new(cShort, 85) : na)

// Alerts — session-aware
canAlert = not useSessionFilter or inTradeSess
alertcondition(enableAlerts and canAlert and longConfirm,  title="A+ LONG ENTRY",  message="A+ LONG entry fired")
alertcondition(enableAlerts and canAlert and shortConfirm, title="A+ SHORT ENTRY", message="A+ SHORT entry fired")
alertcondition(enableExitAlerts and canAlert and partialLong,  title="A+ LONG PARTIAL",  message="A+ LONG: take partial at 3x ATR from entry")
alertcondition(enableExitAlerts and canAlert and partialShort, title="A+ SHORT PARTIAL", message="A+ SHORT: take partial at 3x ATR from entry")
alertcondition(enableExitAlerts and canAlert and exitSoonLong,  title="A+ LONG EXIT SOON",  message="A+ LONG: momentum slowing / EMA spread narrowing")
alertcondition(enableExitAlerts and canAlert and exitSoonShort, title="A+ SHORT EXIT SOON", message="A+ SHORT: momentum slowing / EMA spread narrowing")
alertcondition(enableExitAlerts and canAlert and hardExitLong,  title="A+ LONG HARD EXIT",  message="A+ LONG: trail/VWAP/structure break — exit")
alertcondition(enableExitAlerts and canAlert and hardExitShort, title="A+ SHORT HARD EXIT", message="A+ SHORT: trail/VWAP/structure break — exit")

// --- Bar-close countdown label
var label _cd = na
if showCountdown and barstate.islast
    barMs  = timeframe.in_seconds(timeframe.period) * 1000
    msToEnd = (time + barMs) - timenow
    secLeft = math.max(0, math.floor(msToEnd / 1000))
    if not na(_cd)
        label.delete(_cd)
    _cd := label.new(bar_index, high, str.tostring(secLeft) + "s", xloc=xloc.bar_index, yloc=yloc.abovebar, style=label.style_label_down, textcolor=color.white, color=color.new(color.black, 0), size=size.tiny)
