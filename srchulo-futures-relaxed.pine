//@version=5
indicator("srchulo futures relaxed", overlay=true, max_labels_count=500, max_lines_count=500)

// ===== Theming (distinct from strict)
cLong      = color.rgb(102, 204, 255)
cShort     = color.rgb(255, 160,   0)
cSetupLong = color.new(cLong, 60)
cSetupShort= color.new(cShort,60)

// ---------- Inputs
grpTrend = "Trend / Filters"
emaFastLen = input.int(8, "EMA Fast", group=grpTrend, minval=1)
emaMidLen  = input.int(21, "EMA Mid",  group=grpTrend, minval=1)
emaSlowLen = input.int(34, "EMA Slow", group=grpTrend, minval=1)
useRibbon  = input.bool(true, "Require EMA ribbon alignment (LTF)", group=grpTrend)
htfTF      = input.string("15", "HTF EMA ribbon (minutes)", group=grpTrend)
// NEW: HTF freeze + confirm-on-close
freezeHTF   = input.bool(false,  "Freeze HTF values (no intrabar updates)", group=grpTrend)
calcOnClose = input.bool(false, "Lock signals on bar close (no flicker)",  group=grpTrend)

// === Internal "Moxie-like" slope settings (MTF-aware) — added
grpSlope = "Moxie-like Slope Filter"
slopeMode = input.string("MTF (All selected must agree)", "Slope Mode", options=["Current TF only","MTF (All selected must agree)"], group=grpSlope)
useTF_2m   = input.bool(true,  "Use 2m",  group=grpSlope)
useTF_3m   = input.bool(true,  "Use 3m",  group=grpSlope)
useTF_5m   = input.bool(false, "Use 5m",  group=grpSlope)
useTF_15m  = input.bool(false, "Use 15m", group=grpSlope)
useTF_30m  = input.bool(false, "Use 30m", group=grpSlope)
useTF_1h   = input.bool(false, "Use 1h",  group=grpSlope)
useTF_4h   = input.bool(false, "Use 4h",  group=grpSlope)
useTF_1D   = input.bool(false, "Use 1D",  group=grpSlope)
// tuning
slopeLen      = input.int(5,   "Slope window (bars)", group=grpSlope, minval=2)
slopeSmooth   = input.int(3,   "Slope smoothing (EMA)", group=grpSlope, minval=1)
slopeMagLTF   = input.float(0.00018, "Min slope magnitude (LTF)", group=grpSlope, step=0.00001)
slopeMagHTF   = input.float(0.00013, "Min slope magnitude (MTF)", group=grpSlope, step=0.00001)
persistLTF    = input.int(1,   "Persistence LTF (bars ≥)", group=grpSlope, minval=0, maxval=5)
persistMTF    = input.int(2,   "Persistence MTF (bars ≥)", group=grpSlope, minval=0, maxval=5)
freezeSlopeMTF= input.bool(false, "Freeze MTF at closed bar (no intrabar flicker)", group=grpSlope)

grpVWAP = "VWAP / AVWAP"
useVWAP  = input.bool(true, "Use session VWAP", group=grpVWAP)
useAVWAP = input.bool(true, "Use Anchored VWAP (auto RTH open)", group=grpVWAP)
anchorTime = input.time(timestamp("01 Jan 2025 09:30 -0500"), "Anchored start (unused; auto RTH open)", group=grpVWAP)
pullDist   = input.float(0.10, "Near VWAP distance (% ATR)", group=grpVWAP)
minVWAPBand = input.float(0.20, "Chop guard band (ATR*x)",   group=grpVWAP)

grpVol = "Volume"
volLen  = input.int(50, "Vol SMA", group=grpVol)
volMult = input.float(1.5, "Surge ≥ SMA *", group=grpVol)
requireVol = input.bool(true, "Require volume surge", group=grpVol)

grpDoji = "Candle Patterns"
dojiBodyPct = input.float(0.12, "Doji body ≤ x of range", group=grpDoji)
longWickK   = input.float(2.0,  "Long wick ≥ body *",     group=grpDoji)
nearHiPct   = input.float(0.25, "Body near high",         group=grpDoji)
nearLoPct   = input.float(0.25, "Body near low",          group=grpDoji)

grpCont = "Continuation / Flag"
flagLookback = input.int(25, "Flag window", group=grpCont)
flagTightPct = input.float(0.45, "Flag tightness (≤ ATR * x)", group=grpCont)
breakBufATR  = input.float(0.10, "Breakout buffer (ATR * x)",   group=grpCont)

grpDec = "Decision Engine (weights + gating)"
useCompTrend   = input.bool(true, "Use Trend in score",          group=grpDec)
useCompNearVW  = input.bool(true, "Use Near VWAP in score",      group=grpDec)
useCompVolume  = input.bool(true, "Use Volume in score",         group=grpDec)
useCompPull    = input.bool(true, "Use Pullback/Rally in score", group=grpDec)
useCompReclaim = input.bool(true, "Use VWAP Reclaim in score",   group=grpDec)
useCompFlag    = input.bool(true, "Use Flag in score",           group=grpDec)
useCompPrec    = input.bool(true, "Use Precision EMA in score",  group=grpDec)
useCompCandle  = input.bool(true, "Use Reversal Candle in score",group=grpDec)
useCompEngulf  = input.bool(true, "Use Engulfing in score",      group=grpDec)
useCompRetest  = input.bool(true, "Use VWAP Retest/Flip in score", group=grpDec)
useCompBase    = input.bool(true, "Use High/Low Base in score",  group=grpDec)
useCompTri     = input.bool(false,"Use Asc/Desc Triangle in score", group=grpDec)

useAtrGate       = input.bool(false, "Use ATR floor gate", group=grpDec)
useSessionFilter = input.bool(true,  "Use Session filter", group=grpDec)
useHTFFilter     = input.bool(true,  "Use HTF ribbon filter", group=grpDec)
useSlopeFilter   = input.bool(true,  "Use EMA slope filter", group=grpDec)
useChopGuard     = input.bool(true,  "Use VWAP chop-guard", group=grpDec)
useDailyCapGate  = input.bool(true,  "Use Daily-cap gate", group=grpDec)
triggerMode      = input.string("Breakout", "Trigger mode", options=["Score","Simple","Breakout"], group=grpDec)

// NEW: optional 3rd-ATR block + one-and-done + range guard + soft heads-up proximity
use3rdATRBlock = input.bool(false, "Block entries at 3rd ATR", group=grpDec)
atrMult3_gate  = input.float(3.0,  "ATR x for 3rd-ATR block", group=grpDec, step=0.1)
oneAndDone     = input.bool(false, "One-and-done (stop after first confirm)", group=grpDec)
minRangeATR    = input.float(0.20, "Min bar range (ATR x)", group=grpDec, step=0.05)
nearTicks      = input.int(3, "Heads-up proximity (ticks)", group=grpDec, minval=0)

// NEW: >2nd-ATR momentum+volume filters (symmetrical)
useATR2MomFilter = input.bool(true, "Use >2nd-ATR momentum+vol filter (both sides)", group=grpDec)
volRelaxException = input.float(1.20, "Vol × when >2nd ATR (Relaxed)", group=grpDec, step=0.05)

wTrend   = input.int(2, "W Trend", group=grpDec, minval=0, maxval=5)
wVWAPPb  = input.int(1, "W Near VWAP", group=grpDec, minval=0, maxval=5)
wVolume  = input.int(1, "W Volume", group=grpDec, minval=0, maxval=5)
wPull    = input.int(2, "W Pull/Rally", group=grpDec, minval=0, maxval=5)
wReclaim = input.int(3, "W Reclaim", group=grpDec, minval=0, maxval=5)
wFlag    = input.int(0, "W Flag", group=grpDec, minval=0, maxval=5)
wPrec    = input.int(2, "W Precision", group=grpDec, minval=0, maxval=5)
wCandle  = input.int(1, "W Candle", group=grpDec, minval=0, maxval=5)
wEngulf  = input.int(2, "W Engulf", group=grpDec, minval=0, maxval=5)
wRetest  = input.int(3, "W VWAP Retest", group=grpDec, minval=0, maxval=5)
wBase    = input.int(2, "W Base", group=grpDec, minval=0, maxval=5)
wTri     = input.int(1, "W Triangle", group=grpDec, minval=0, maxval=5)

threshLong  = input.int(5, "Score threshold LONG",  group=grpDec, minval=1)
threshShort = input.int(5, "Score threshold SHORT", group=grpDec, minval=1)
minAtrTicks = input.int(22,"Min ATR (ticks) gate",  group=grpDec)
entryConfirmTicks = input.int(1, "Entry confirmation (ticks beyond signal bar)", group=grpDec)
cooldownBars = input.int(10, "Cooldown bars", group=grpDec)
maxSignalsPerDay = input.int(4, "Max signals per day", group=grpDec)
sessionStr = input.session("0935-1130,1330-1555", "RTH windows (exchange time)", group=grpDec)

// Pattern tolerances
ticksTol   = input.int(4, "Structure tolerance (ticks)", group=grpDec)
retestBars = input.int(5, "VWAP retest within N bars",   group=grpDec)

// ---------- Show / Alerts
grpShow = "Show / Alerts"
showContext   = input.bool(false,  "Plot EMAs + VWAP/AVWAP", group=grpShow)
showSetups    = input.bool(true,  "Plot setup arrows",      group=grpShow)
enableAlerts  = input.bool(true,  "Enable confirmed entry alerts", group=grpShow)
showCountdown = input.bool(true,  "Show bar-close countdown", group=grpShow)

// ---------- Core series
atrLen = 14
atr = ta.atr(atrLen)
safeMintick = syminfo.mintick == 0.0 ? 0.25 : syminfo.mintick
atrTicks = math.round(atr / safeMintick)

emaF = ta.ema(close, emaFastLen)
emaM = ta.ema(close, emaMidLen)
emaS = ta.ema(close, emaSlowLen)

ribbonBull = emaF > emaM and emaM > emaS
ribbonBear = emaF < emaM and emaM < emaS
trendOkLong  = useRibbon ? ribbonBull : true
trendOkShort = useRibbon ? ribbonBear : true

// Keep original simple slope vars (used elsewhere visually if needed)
emaSlopeLong  = emaM > emaM[5] and emaS > emaS[5]
emaSlopeShort = emaM < emaM[5] and emaS < emaS[5]

// -------------------- Session & VWAPs --------------------
vwap = ta.vwap(close)
inSess = not na(time(timeframe.period, sessionStr))
sessionStart = inSess and not inSess[1]

// Anchored VWAP auto-anchored to RTH open
var float avwap = na
var float aPV = 0.0
var float aV  = 0.0
if barstate.isnew
    if sessionStart
        aPV := 0.0
        aV  := 0.0
    if inSess
        tp = (high + low + close) / 3.0
        aPV += tp * volume
        aV  += volume
        avwap := aV > 0 ? aPV / aV : na
    if not inSess
        aPV := 0.0
        aV  := 0.0
        avwap := na

// context plots
plot((showContext and useVWAP)  ? vwap  : na, "VWAP",  color=color.new(color.teal, 0), linewidth=2)
plot((showContext and useAVWAP) ? avwap : na, "Anchor VWAP (RTH Open)", color=color.new(color.purple, 0), linewidth=2)
plot(showContext ? emaF : na, "EMA Fast", color=color.new(color.white, 0))
plot(showContext ? emaM : na, "EMA Mid",  color=color.new(color.orange, 0))
plot(showContext ? emaS : na, "EMA Slow", color=color.new(color.maroon, 0))

// HTF EMA ribbon  ✅ freeze to last closed HTF bar
htfE1 = request.security(syminfo.tickerid, htfTF, ta.ema(close, emaFastLen),  lookahead=freezeHTF ? barmerge.lookahead_on : barmerge.lookahead_off)
htfE2 = request.security(syminfo.tickerid, htfTF, ta.ema(close, emaMidLen),   lookahead=freezeHTF ? barmerge.lookahead_on : barmerge.lookahead_off)
htfE3 = request.security(syminfo.tickerid, htfTF, ta.ema(close, emaSlowLen),  lookahead=freezeHTF ? barmerge.lookahead_on : barmerge.lookahead_off)
htfBull = htfE1 > htfE2 and htfE2 > htfE3
htfBear = htfE1 < htfE2 and htfE2 < htfE3

// --- HTF heads-up (preview vs locked) ---
htfBull_preview = request.security(syminfo.tickerid, htfTF, ta.ema(close, emaFastLen) > ta.ema(close, emaMidLen) and ta.ema(close, emaMidLen) > ta.ema(close, emaSlowLen), lookahead=barmerge.lookahead_off)
htfBear_preview = request.security(syminfo.tickerid, htfTF, ta.ema(close, emaFastLen) < ta.ema(close, emaMidLen) and ta.ema(close, emaMidLen) < ta.ema(close, emaSlowLen), lookahead=barmerge.lookahead_off)
htfBull_locked = htfBull
htfBear_locked = htfBear
headsUpLong  = htfBull_preview and not htfBull_locked
headsUpShort = htfBear_preview and not htfBear_locked
plotshape(headsUpLong,  title="HTF Heads-Up (Long)",  style=shape.circle, location=location.top,    size=size.tiny, color=color.new(color.green, 0))
plotshape(headsUpShort, title="HTF Heads-Up (Short)", style=shape.circle, location=location.bottom, size=size.tiny, color=color.new(color.red,   0))

// Volume
volSMA = ta.sma(volume, volLen)
volSurge = volume >= volSMA * volMult
volOK = requireVol ? volSurge : true

// Candles
rng = math.max(high - low, safeMintick)
body = math.abs(close - open)
upper = high - math.max(open, close)
lower = math.min(open, close) - low
isDoji = body <= rng * dojiBodyPct
nearHighBody = (high - math.max(open, close)) <= rng * nearHiPct
nearLowBody  = (math.min(open, close) - low)  <= rng * nearLoPct
dragonfly = isDoji and lower >= body * longWickK and nearHighBody
gravestone = isDoji and upper >= body * longWickK and nearLowBody
hammer = (lower >= body * longWickK) and nearHighBody and not isDoji
shootingStar = (upper >= body * longWickK) and nearLowBody and not isDoji

// Engulf / inside
bullEngulf = close>open and open<=close[1] and close>=open[1] and close>close[1]
bearEngulf = close<open and open>=close[1] and close<=open[1] and close<close[1]
insideBar  = high<high[1] and low>low[1]

// Proximity + chop guard
withinPctOfATR(src, pct) => na(src) ? false : math.abs(close - src) <= atr * pct
nearAnyVWAP_raw = (useVWAP and withinPctOfATR(vwap, pullDist)) or (useAVWAP and withinPctOfATR(avwap, pullDist))

// raw chop signal each bar
cgRaw = (useVWAP and withinPctOfATR(vwap, minVWAPBand)) or (useAVWAP and withinPctOfATR(avwap, minVWAPBand))

// close-only stabilized version (no self-reference)
inVWAPChop_close = ta.valuewhen(barstate.isconfirmed, cgRaw, 0)

// choose raw vs close-only based on toggle
inVWAPChop_raw = cgRaw
inVWAPChop     = useChopGuard ? (calcOnClose ? inVWAPChop_close : inVWAPChop_raw) : false

nearAnyVWAP = nearAnyVWAP_raw

// ================== NEW SLOPE (MOXIE-LIKE) LOGIC ==================
// helpers
f_internal_slope(_close, _fastLen, _midLen, _slowLen, _slopeLen, _smooth) =>
    _fast   = ta.ema(_close, _fastLen)
    _mid    = ta.ema(_close, _midLen)
    _slow   = ta.ema(_close, _slowLen)
    _spread = (_fast - _mid) + (_mid - _slow)
    _raw    = ta.linreg(_spread, _slopeLen, 0)
    _sm     = _smooth > 1 ? ta.ema(_raw, _smooth) : _raw
    nz(_sm) / math.max(math.abs(_mid), 1e-6)

f_slope_ok(tf, magMin, persistBars, _freeze) =>
    _lk = _freeze ? barmerge.lookahead_on : barmerge.lookahead_off
    _s  = request.security(syminfo.tickerid, tf, f_internal_slope(close, emaFastLen, emaMidLen, emaSlowLen, slopeLen, slopeSmooth), lookahead=_lk)
    _up   = _s >  magMin
    _down = _s < -magMin
    _upOK   = ta.barssince(_down) > persistBars
    _downOK = ta.barssince(_up)   > persistBars
    [_up, _down, _upOK, _downOK]

f_slope_current() =>
    _s  = f_internal_slope(close, emaFastLen, emaMidLen, emaSlowLen, slopeLen, slopeSmooth)
    _up   = _s >  slopeMagLTF
    _down = _s < -slopeMagLTF
    _upOK   = ta.barssince(_down) > persistLTF
    _downOK = ta.barssince(_up)   > persistLTF
    [_up, _down, _upOK, _downOK]

// consensus TF labels
var string TF2    = "2"
var string TF3    = "3"
var string TF5    = "5"
var string TF15   = "15"
var string TF30   = "30"
var string TF60   = "60"
var string TF240  = "240"
var string TFD    = "D"

// current TF
[ctf_up, ctf_dn, ctf_upok, ctf_dnok] = f_slope_current()

// MTF aggregation
mtf_any_selected = false
mtf_all_up = true
mtf_all_dn = true

if slopeMode == "MTF (All selected must agree)"
    if useTF_2m
        mtf_any_selected := true
        [u2, d2, uok2, dok2] = f_slope_ok(TF2, slopeMagHTF, persistMTF, freezeSlopeMTF)
        mtf_all_up := mtf_all_up and (u2 and uok2)
        mtf_all_dn := mtf_all_dn and (d2 and dok2)
    if useTF_3m
        mtf_any_selected := true
        [u3, d3, uok3, dok3] = f_slope_ok(TF3, slopeMagHTF, persistMTF, freezeSlopeMTF)
        mtf_all_up := mtf_all_up and (u3 and uok3)
        mtf_all_dn := mtf_all_dn and (d3 and dok3)
    if useTF_5m
        mtf_any_selected := true
        [u5, d5, uok5, dok5] = f_slope_ok(TF5, slopeMagHTF, persistMTF, freezeSlopeMTF)
        mtf_all_up := mtf_all_up and (u5 and uok5)
        mtf_all_dn := mtf_all_dn and (d5 and dok5)
    if useTF_15m
        mtf_any_selected := true
        [u15, d15, uok15, dok15] = f_slope_ok(TF15, slopeMagHTF, persistMTF, freezeSlopeMTF)
        mtf_all_up := mtf_all_up and (u15 and uok15)
        mtf_all_dn := mtf_all_dn and (d15 and dok15)
    if useTF_30m
        mtf_any_selected := true
        [u30, d30, uok30, dok30] = f_slope_ok(TF30, slopeMagHTF, persistMTF, freezeSlopeMTF)
        mtf_all_up := mtf_all_up and (u30 and uok30)
        mtf_all_dn := mtf_all_dn and (d30 and dok30)
    if useTF_1h
        mtf_any_selected := true
        [u60, d60, uok60, dok60] = f_slope_ok(TF60, slopeMagHTF, persistMTF, freezeSlopeMTF)
        mtf_all_up := mtf_all_up and (u60 and uok60)
        mtf_all_dn := mtf_all_dn and (d60 and dok60)
    if useTF_4h
        mtf_any_selected := true
        [u240, d240, uok240, dok240] = f_slope_ok(TF240, slopeMagHTF, persistMTF, freezeSlopeMTF)
        mtf_all_up := mtf_all_up and (u240 and uok240)
        mtf_all_dn := mtf_all_dn and (d240 and dok240)
    if useTF_1D
        mtf_any_selected := true
        [ud, dd, uokd, dokd] = f_slope_ok(TFD, slopeMagHTF, persistMTF, freezeSlopeMTF)
        mtf_all_up := mtf_all_up and (ud and uokd)
        mtf_all_dn := mtf_all_dn and (dd and dokd)

// Fallback: if MTF mode but nothing selected, use current TF
useCurrentFallback = (slopeMode == "MTF (All selected must agree)") and (not mtf_any_selected)

// Final slope gates for relaxed script
slopeLongOK_new  = slopeMode == "Current TF only"      ? (ctf_up and ctf_upok) :
                   useCurrentFallback                  ? (ctf_up and ctf_upok)  :
                   mtf_all_up

slopeShortOK_new = slopeMode == "Current TF only"      ? (ctf_dn and ctf_dnok) :
                   useCurrentFallback                  ? (ctf_dn and ctf_dnok)  :
                   mtf_all_dn
// ================== END NEW SLOPE LOGIC ==================

// Setups
bullReversalCandle  = hammer or dragonfly or (close > open and close > open[1] and low <= low[1])
pullbackLong        = trendOkLong  and nearAnyVWAP and bullReversalCandle and close > ta.highest(high[1], 1)
bearReversalCandle  = shootingStar or gravestone or (close < open and close < open[1] and high >= high[1])
rallyShort          = trendOkShort and nearAnyVWAP and bearReversalCandle and close < ta.lowest(low[1], 1)

wasBelowVWAP  = useVWAP and close[1] < vwap[1]
nowAboveVWAP  = useVWAP and close > vwap
wasAboveVWAP  = useVWAP and close[1] > vwap[1]
nowBelowVWAP  = useVWAP and close < vwap

vwapReclaimLong  = trendOkLong  and (wasBelowVWAP and nowAboveVWAP) and volOK
vwapReclaimShort = trendOkShort and (wasAboveVWAP and nowBelowVWAP) and volOK

// VWAP retest/flip (after reclaim)
tolP = atr * 0.10
bullRetest = ta.barssince(wasBelowVWAP and nowAboveVWAP) <= retestBars and math.abs(low - vwap)  <= tolP and close>vwap
bearRetest = ta.barssince(wasAboveVWAP and nowBelowVWAP) <= retestBars and math.abs(high - vwap) <= tolP and close<vwap

// Flags / Bases / Triangles
rangeHi = ta.highest(high, flagLookback)
rangeLo = ta.lowest(low,  flagLookback)
rangeTight = (rangeHi - rangeLo) <= atr * flagTightPct
bullFlag = trendOkLong  and rangeTight and close > rangeHi[1] + atr * breakBufATR
bearFlag = trendOkShort and rangeTight and close < rangeLo[1] - atr * breakBufATR
tolPx  = ticksTol * safeMintick
flatHi = math.abs(rangeHi - rangeHi[1]) <= tolPx
flatLo = math.abs(rangeLo - rangeLo[1]) <= tolPx
riseL  = ta.lowest(low, flagLookback)  > ta.lowest(low, flagLookback)[1]
fallH  = ta.highest(high,flagLookback) < ta.highest(high,flagLookback)[1]
highBase = trendOkLong  and rangeTight and flatHi and riseL
lowBase  = trendOkShort and rangeTight and flatLo and fallH
ascTri   = trendOkLong  and flatHi and riseL
descTri  = trendOkShort and flatLo and fallH

// Precision
precisionLong = trendOkLong  and (math.abs(close - emaM) <= atr * 0.15 or math.abs(close - emaS) <= atr * 0.15) and bullReversalCandle
precisionShort= trendOkShort and (math.abs(close - emaM) <= atr * 0.15 or math.abs(close - emaS) <= atr * 0.15) and bearReversalCandle

// Scoring
reclaimLongPrim  = wasBelowVWAP and nowAboveVWAP
reclaimShortPrim = wasAboveVWAP and nowBelowVWAP
bullCandle = hammer or dragonfly
bearCandle = shootingStar or gravestone
scoreAdd(c, w, use) => use and c ? w : 0

longScore = scoreAdd(trendOkLong, wTrend, useCompTrend) + scoreAdd(not inVWAPChop and nearAnyVWAP, wVWAPPb, useCompNearVW) + scoreAdd(volOK, wVolume, useCompVolume) + scoreAdd(pullbackLong, wPull, useCompPull) + scoreAdd(reclaimLongPrim, wReclaim, useCompReclaim) + scoreAdd(bullFlag, wFlag, useCompFlag) + scoreAdd(precisionLong, wPrec, useCompPrec) + scoreAdd(bullCandle, wCandle, useCompCandle) + scoreAdd(bullEngulf, wEngulf, useCompEngulf) + scoreAdd(bullRetest, wRetest, useCompRetest) + scoreAdd(highBase, wBase, useCompBase) + scoreAdd(ascTri, wTri, useCompTri)

shortScore = scoreAdd(trendOkShort, wTrend, useCompTrend) + scoreAdd(not inVWAPChop and nearAnyVWAP, wVWAPPb, useCompNearVW) + scoreAdd(volOK, wVolume, useCompVolume) + scoreAdd(rallyShort, wPull, useCompPull) + scoreAdd(reclaimShortPrim, wReclaim, useCompReclaim) + scoreAdd(bearFlag, wFlag, useCompFlag) + scoreAdd(precisionShort, wPrec, useCompPrec) + scoreAdd(bearCandle, wCandle, useCompCandle) + scoreAdd(bearEngulf, wEngulf, useCompEngulf) + scoreAdd(bearRetest, wRetest, useCompRetest) + scoreAdd(lowBase, wBase, useCompBase) + scoreAdd(descTri, wTri, useCompTri)

// Gating toggles  (ONLY change here: use new slope gates)
gateSessOK   = useSessionFilter ? inSess : true
gateAtrOK    = useAtrGate ? atrTicks >= minAtrTicks : true
gateHTFLong  = useHTFFilter ? htfBull : true
gateHTFShort = useHTFFilter ? htfBear : true
gateSlopeL   = useSlopeFilter ? slopeLongOK_new  : true
gateSlopeS   = useSlopeFilter ? slopeShortOK_new : true

// Cooldown + daily cap + one-and-done
var int  lastSignalBar   = na
newDay                = ta.change(time("D")) != 0
var int  signalsToday    = 0
var bool tookEntryToday  = false
if newDay
    signalsToday   := 0
    lastSignalBar  := na
    tookEntryToday := false

readyForNew = na(lastSignalBar) or (bar_index - lastSignalBar > cooldownBars)
capRaw      = signalsToday < maxSignalsPerDay
gateDailyOK = useDailyCapGate ? capRaw : true

// SIMPLE triggers (bypass score if chosen)
simpleLong  = trendOkLong  and (precisionLong or vwapReclaimLong or bullRetest or bullEngulf or pullbackLong or bullFlag or highBase or ascTri) and (not useChopGuard or not inVWAPChop)
simpleShort = trendOkShort and (precisionShort or vwapReclaimShort or bearRetest or bearEngulf or rallyShort or bearFlag or lowBase  or descTri) and (not useChopGuard or not inVWAPChop)

// NEW: 3rd-ATR block + range quality + one-and-done
ema34      = ta.ema(close, 34)
up3_gate   = ema34 + atr * atrMult3_gate
dn3_gate   = ema34 - atr * atrMult3_gate
atOrBeyond3rd = close >= up3_gate or close <= dn3_gate
rangeOK    = (high - low) >= atr * minRangeATR

// NEW: >2nd-ATR helpers (symmetrical, relaxed)
up2_gate = ema34 + atr * 2.0
dn2_gate = ema34 - atr * 2.0
momRise2 = close > close[1] and close[1] > close[2]
momFall2 = close < close[1] and close[1] < close[2]
relaxedATRMomOK_L = (not atOrBeyond3rd) and ((close <= up2_gate and (emaSlopeLong or htfBull_locked)) or (close > up2_gate and (emaSlopeLong or htfBull_locked) and momRise2 and (volume >= volSMA * volRelaxException)))
relaxedATRMomOK_S = (not atOrBeyond3rd) and ((close >= dn2_gate and (emaSlopeShort or htfBear_locked)) or (close < dn2_gate and (emaSlopeShort or htfBear_locked) and momFall2 and (volume >= volSMA * volRelaxException)))

// Final setups (mode driven) — Breakout mode uses gates only (base=true)
// Build base gates then add extra guards
baseLongGates_core  = readyForNew and gateDailyOK and gateSessOK and gateAtrOK and gateHTFLong  and gateSlopeL and trendOkLong  and (not useChopGuard or not inVWAPChop)
baseShortGates_core = readyForNew and gateDailyOK and gateSessOK and gateAtrOK and gateHTFShort and gateSlopeS and trendOkShort and (not useChopGuard or not inVWAPChop)

baseLongGates  = baseLongGates_core  and (not use3rdATRBlock or not atOrBeyond3rd) and (not oneAndDone or not tookEntryToday) and (not useATR2MomFilter or relaxedATRMomOK_L)
baseShortGates = baseShortGates_core and (not use3rdATRBlock or not atOrBeyond3rd) and (not oneAndDone or not tookEntryToday) and (not useATR2MomFilter or relaxedATRMomOK_S)

useScore   = triggerMode == "Score"
useSimple  = triggerMode == "Simple"
useBreak   = triggerMode == "Breakout"
baseLongSetup  = (useScore ? (longScore  >= threshLong)  : useSimple ? simpleLong  : true)  and baseLongGates
baseShortSetup = (useScore ? (shortScore >= threshShort) : useSimple ? simpleShort : true)  and baseShortGates

// Confirmation
longStopPrice   = high + entryConfirmTicks * safeMintick
shortStopPrice  = low  - entryConfirmTicks * safeMintick
breakoutLongNow  = (high - low) >= atr * 0.20 and high >= high[1] + entryConfirmTicks * safeMintick
breakoutShortNow = (high - low) >= atr * 0.20 and low  <= low[1]  - entryConfirmTicks * safeMintick
longConfirm_raw  = (useBreak ? (baseLongSetup  and breakoutLongNow)  : (baseLongSetup[1]  and high >= longStopPrice[1]))  and rangeOK
shortConfirm_raw = (useBreak ? (baseShortSetup and breakoutShortNow) : (baseShortSetup[1] and low  <= shortStopPrice[1])) and rangeOK

// Finalize to bar close if requested
finalize(b) => calcOnClose ? (barstate.isconfirmed ? b : false) : b
longConfirm  = finalize(longConfirm_raw)
shortConfirm = finalize(shortConfirm_raw)

// ---- Soft heads-up alert (near trigger with preview HTF)
pxBuf = nearTicks * safeMintick
nearTriggerLong  = (useBreak ? (baseLongSetup  and high >= (high[1] + entryConfirmTicks * safeMintick) - pxBuf) : (baseLongSetup[1] and high >= ((high[1] + entryConfirmTicks * safeMintick) - pxBuf)))
nearTriggerShort = (useBreak ? (baseShortSetup and low  <= (low[1]  - entryConfirmTicks * safeMintick) + pxBuf) : (baseShortSetup[1] and low  <= ((low[1]  - entryConfirmTicks * safeMintick) + pxBuf)))
softHeadsUpLong  = (not useSessionFilter or inSess) and nearTriggerLong  and htfBull_preview and not htfBull_locked
softHeadsUpShort = (not useSessionFilter or inSess) and nearTriggerShort and htfBear_preview and not htfBear_locked
alertcondition(softHeadsUpLong,  title="Heads-Up LONG",  message="Heads-up: close could confirm LONG")
alertcondition(softHeadsUpShort, title="Heads-Up SHORT", message="Heads-up: close could confirm SHORT")

// Gate Debug panel
grpDbg = "Debug"
showGateDebug = input.bool(false, "Show Gate Debug panel", group=grpDbg)
gateColor(b) => b ? color.new(color.lime, 0) : color.new(color.red, 0)
textYesNo(b) => b ? "YES" : "NO"
var table dbg = na
if barstate.isfirst
    dbg := table.new(position.top_right, 4, 16, border_width=1)
if showGateDebug and barstate.islast
    modeTxt = useScore ? "Score" : useSimple ? "Simple" : "Breakout"
    table.cell(dbg, 0, 0, "Gate", text_color=color.black, bgcolor=color.new(color.yellow, 0))
    table.cell(dbg, 1, 0, "LONG", text_color=color.black, bgcolor=color.new(color.yellow, 0))
    table.cell(dbg, 2, 0, "SHORT", text_color=color.black, bgcolor=color.new(color.yellow, 0))
    table.cell(dbg, 3, 0, "Mode: " + modeTxt, text_color=color.black, bgcolor=color.new(color.orange, 20))
    table.cell(dbg, 0, 1, "Score >= Thresh")
    table.cell(dbg, 1, 1, textYesNo(longScore  >= threshLong),  bgcolor=gateColor(longScore  >= threshLong))
    table.cell(dbg, 2, 1, textYesNo(shortScore >= threshShort), bgcolor=gateColor(shortScore >= threshShort))
    table.cell(dbg, 0, 2, "Cooldown OK")
    table.cell(dbg, 1, 2, textYesNo(readyForNew), bgcolor=gateColor(readyForNew))
    table.cell(dbg, 2, 2, textYesNo(readyForNew), bgcolor=gateColor(readyForNew))
    table.cell(dbg, 0, 3, "Daily Cap OK")
    table.cell(dbg, 1, 3, textYesNo(gateDailyOK), bgcolor=gateColor(gateDailyOK))
    table.cell(dbg, 2, 3, textYesNo(gateDailyOK), bgcolor=gateColor(gateDailyOK))
    table.cell(dbg, 0, 4, "Session OK")
    table.cell(dbg, 1, 4, textYesNo(gateSessOK), bgcolor=gateColor(gateSessOK))
    table.cell(dbg, 2, 4, textYesNo(gateSessOK), bgcolor=gateColor(gateSessOK))
    table.cell(dbg, 0, 5, "ATR OK")
    table.cell(dbg, 1, 5, textYesNo(gateAtrOK), bgcolor=gateColor(gateAtrOK))
    table.cell(dbg, 2, 5, textYesNo(gateAtrOK), bgcolor=gateColor(gateAtrOK))
    table.cell(dbg, 0, 6, "HTF OK")
    table.cell(dbg, 1, 6, textYesNo(gateHTFLong),  bgcolor=gateColor(gateHTFLong))
    table.cell(dbg, 2, 6, textYesNo(gateHTFShort), bgcolor=gateColor(gateHTFShort))
    table.cell(dbg, 0, 7, "Slope OK")
    table.cell(dbg, 1, 7, textYesNo(gateSlopeL), bgcolor=gateColor(gateSlopeL))
    table.cell(dbg, 2, 7, textYesNo(gateSlopeS), bgcolor=gateColor(gateSlopeS))
    cgOK_vis = not inVWAPChop or not useChopGuard
    table.cell(dbg, 0, 8, "ChopGuard OK")
    table.cell(dbg, 1, 8, textYesNo(cgOK_vis), bgcolor=gateColor(cgOK_vis))
    table.cell(dbg, 2, 8, textYesNo(cgOK_vis), bgcolor=gateColor(cgOK_vis))
    table.cell(dbg, 0, 9, "Vol Surge")
    table.cell(dbg, 1, 9, textYesNo(volSurge), bgcolor=gateColor(volSurge))
    table.cell(dbg, 2, 9, textYesNo(volSurge), bgcolor=gateColor(volSurge))

// latch cooldown & one-and-done
if barstate.isconfirmed and (longConfirm or shortConfirm)
    lastSignalBar := bar_index
    signalsToday += 1
    tookEntryToday := true

// ==================== EXIT / MANAGEMENT ====================
grpExit = "Exit / Management (Continuation Aware)"
usePartialATR    = input.bool(true, "Take partial at 3×ATR from entry", group=grpExit)
partialATRs      = input.float(3.0, "Partial ATR multiple", group=grpExit, step=0.1)
trailATRs        = input.float(1.5, "ATR trail (from HH/LL since entry)", group=grpExit, step=0.1)
exitOnMomHook    = input.bool(true, "Exit-soon on momentum hook (MACD hist turns up/down)", group=grpExit)
exitOnPriorHL    = input.bool(true, "Hard exit on prior bar H/L break", group=grpExit)
exitOnVWAPFlip   = input.bool(true, "Hard exit on VWAP/AVWAP reclaim", group=grpExit)
exitOnEMASpread  = input.bool(true, "Exit-soon on EMA spread narrowing", group=grpExit)
emaSpreadLook    = input.int(3, "EMA spread lookback (bars)", group=grpExit, minval=1)
showTrails       = input.bool(true, "Plot dynamic ATR trails", group=grpExit)
enableExitAlerts = input.bool(true, "Enable exit/partial alerts", group=grpExit)
exitHookBars     = input.int(2, "MACD hook pivot bars", group=grpExit, minval=1, maxval=5)
spreadShrinkPct  = input.float(0.03, "EMA spread shrink ≥", group=grpExit, step=0.005)
needStruct       = input.bool(true,  "Require LH/HL with hook", group=grpExit)
needVolFade      = input.bool(false, "Require volume < SMA on exit-soon", group=grpExit)
showExitSoonFlags= input.bool(true,  "Show 'Exit Soon' flags", group=grpExit)
showHardExitFlags= input.bool(true,  "Show 'Hard Exit' crosses", group=grpExit)
exitSoonColor    = input.color(color.rgb(167, 139, 250), "Exit Soon color", group=grpExit)
hardExitColor    = input.color(color.rgb(255, 77, 136),  "Hard Exit color", group=grpExit)

[macdLine, macdSignal, macdHist] = ta.macd(close, 12, 26, 9)
spreadNow = math.abs(emaM - emaF)
spreadPrev = math.abs(emaM[emaSpreadLook] - emaF[emaSpreadLook])

var bool inLong = false
var bool inShort = false
var float entryPrice = na
var int   entrySide  = 0
longEnter  = barstate.isconfirmed and longConfirm
shortEnter = barstate.isconfirmed and shortConfirm
if longEnter
    inLong := true
    inShort := false
    entryPrice := close
    entrySide := 1
if shortEnter
    inShort := true
    inLong := false
    entryPrice := close
    entrySide := -1

// Running extremes since entry
var float runLL = na
var float runHH = na
runLL := inLong  ? ((na(runLL[1]) or longEnter)  ? low  : math.min(runLL[1], low))  : na
runHH := inShort ? ((na(runHH[1]) or shortEnter) ? high : math.max(runHH[1], high)) : na
trailLong  = nz(runLL) - atr * trailATRs
trailShort = nz(runHH) + atr * trailATRs

partialLong  = inLong  and usePartialATR and close >= entryPrice + atr * partialATRs
partialShort = inShort and usePartialATR and close <= entryPrice - atr * partialATRs

// Exit-Soon flags
macdHookDn    = ta.change(macdHist) < 0 and ta.change(macdHist, exitHookBars) >= 0
macdHookUp    = ta.change(macdHist) > 0 and ta.change(macdHist, exitHookBars) <= 0
spreadNarrow  = spreadNow <= spreadPrev * (1 - spreadShrinkPct)
lowerHigh     = high <= high[1]
higherLow     = low  >= low[1]
volFade       = volume < volSMA
momHookLong   = inLong  and exitOnMomHook and macdHookDn
momHookShort  = inShort and exitOnMomHook and macdHookUp
emaNarrowLong  = inLong  and exitOnEMASpread and spreadNarrow
emaNarrowShort = inShort and exitOnEMASpread and spreadNarrow
hardExitLong  = inLong  and ((close <= trailLong) or (exitOnVWAPFlip and ((useVWAP and close < vwap) or (useAVWAP and (not na(avwap) and close < avwap)))) or (exitOnPriorHL and close < low[1]))
hardExitShort = inShort and ((close >= trailShort) or (exitOnVWAPFlip and ((useVWAP and close > vwap) or (useAVWAP and (not na(avwap) and close > avwap)))) or (exitOnPriorHL and close > high[1]))
exitSoonLong  = inLong  and ((momHookLong or emaNarrowLong))  and (not needStruct or lowerHigh)  and (not needVolFade or volFade)
exitSoonShort = inShort and ((momHookShort or emaNarrowShort)) and (not needStruct or higherLow) and (not needVolFade or volFade)

// auto-flat on hard exit
if barstate.isconfirmed and hardExitLong
    inLong := false
    entrySide := 0
if barstate.isconfirmed and hardExitShort
    inShort := false
    entrySide := 0

// Trails & Exit markers
plot(showTrails and inLong  ? trailLong  : na, "Long ATR Trail",  color=cLong,  linewidth=1, style=plot.style_linebr)
plot(showTrails and inShort ? trailShort : na, "Short ATR Trail", color=cShort, linewidth=1, style=plot.style_linebr)
plotshape(partialLong,  title="Partial LONG 3xATR",  style=shape.circle, location=location.abovebar, color=cLong,  size=size.tiny, text="PARTIAL")
plotshape(partialShort, title="Partial SHORT 3xATR", style=shape.circle, location=location.belowbar, color=cShort, size=size.tiny, text="PARTIAL")
plotshape(showExitSoonFlags and exitSoonLong,  title="Exit Soon LONG",  style=shape.flag,  location=location.abovebar, color=exitSoonColor, size=size.tiny, text="EXIT SOON")
plotshape(showExitSoonFlags and exitSoonShort, title="Exit Soon SHORT", style=shape.flag,  location=location.belowbar, color=exitSoonColor, size=size.tiny, text="EXIT")
plotshape(showHardExitFlags and hardExitLong,  title="HARD EXIT LONG",  style=shape.cross, location=location.abovebar, color=hardExitColor, size=size.tiny, text="EXIT")
plotshape(showHardExitFlags and hardExitShort, title="HARD EXIT SHORT", style=shape.cross, location=location.belowbar, color=hardExitColor, size=size.tiny, text="EXIT")

// Plot arrows (relaxed theme)
plotshape(showSetups and baseLongSetup,  title="Setup LONG",  style=shape.triangleup,   location=location.belowbar, color=cSetupLong,  size=size.tiny, text="setup")
plotshape(showSetups and baseShortSetup, title="Setup SHORT", style=shape.triangledown, location=location.abovebar, color=cSetupShort, size=size.tiny, text="setup")
plotshape(longConfirm,  title="A+ LONG (confirmed)",  style=shape.triangleup,   location=location.belowbar, color=cLong,  size=size.large, text="A+ LONG")
plotshape(shortConfirm, title="A+ SHORT (confirmed)", style=shape.triangledown, location=location.abovebar, color=cShort, size=size.large, text="A+ SHORT")
bgcolor(longConfirm ? color.new(cLong, 85) : shortConfirm ? color.new(cShort, 85) : na)

// Alerts — session-aware
canAlert = not useSessionFilter or inSess
alertcondition(enableAlerts and canAlert and longConfirm,  title="A+ LONG ENTRY",  message="A+ LONG entry fired")
alertcondition(enableAlerts and canAlert and shortConfirm, title="A+ SHORT ENTRY", message="A+ SHORT entry fired")

// Exit/Partial Alerts — session-aware
alertcondition(enableExitAlerts and canAlert and partialLong,  title="A+ LONG PARTIAL",  message="A+ LONG: take partial at 3x ATR from entry")
alertcondition(enableExitAlerts and canAlert and partialShort, title="A+ SHORT PARTIAL", message="A+ SHORT: take partial at 3x ATR from entry")
alertcondition(enableExitAlerts and canAlert and exitSoonLong,  title="A+ LONG EXIT SOON",  message="A+ LONG: momentum slowing / EMA spread narrowing")
alertcondition(enableExitAlerts and canAlert and exitSoonShort, title="A+ SHORT EXIT SOON", message="A+ SHORT: momentum slowing / EMA spread narrowing")
alertcondition(enableExitAlerts and canAlert and hardExitLong,  title="A+ LONG HARD EXIT",  message="A+ LONG: trail/VWAP/structure break — exit")
alertcondition(enableExitAlerts and canAlert and hardExitShort, title="A+ SHORT HARD EXIT", message="A+ SHORT: trail/VWAP/structure break — exit")

// --- Bar-close countdown label
var label _cd = na
if showCountdown and barstate.islast
    barMs   = timeframe.in_seconds(timeframe.period) * 1000
    msToEnd = (time + barMs) - timenow
    secLeft = math.max(0, math.floor(msToEnd / 1000))
    if not na(_cd) 
        label.delete(_cd)
    _cd := label.new(bar_index, high, str.tostring(secLeft) + "s", xloc=xloc.bar_index, yloc=yloc.abovebar, style=label.style_label_down, textcolor=color.white, color=color.new(color.black, 0), size=size.tiny)
